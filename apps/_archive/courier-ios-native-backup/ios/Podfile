begin
  require_relative '../node_modules/react-native/scripts/react_native_pods'
rescue LoadError
  # Fallback for pnpm hoisted layout where the script lives in the pnpm store
  require '/Users/papadev/Downloads/gosenderr-2-native-courier-app/node_modules/.pnpm/react-native@0.76.5_@babel+core@7.28.6_@babel+preset-env@7.29.0_@types+react@18.3.1_react@18.3.1/node_modules/react-native/scripts/react_native_pods'
end
begin
  require_relative '../node_modules/@react-native-community/cli-platform-ios/native_modules'
rescue LoadError
  # Fallback to pnpm store copy
  require '/Users/papadev/Downloads/gosenderr-2-native-courier-app/node_modules/.pnpm/@react-native-community+cli-platform-ios@13.6.9/node_modules/@react-native-community/cli-platform-ios/native_modules'
end

platform :ios, '15.1'
prepare_react_native_project!

react_native_path = '../node_modules/react-native'
# Fallback to pnpm store path if the package.json isn't visible via the symlink
unless File.exist?(File.expand_path("#{react_native_path}/package.json", __dir__))
  react_native_path = '/Users/papadev/Downloads/gosenderr-2-native-courier-app/node_modules/.pnpm/react-native@0.76.5_@babel+core@7.28.6_@babel+preset-env@7.29.0_@types+react@18.3.1_react@18.3.1/node_modules/react-native'
end
firebase_version = '10.24.0'

target 'Senderrappios' do
  config = use_native_modules!

  use_react_native!(
    :path => react_native_path,
    :hermes_enabled => true,
    :fabric_enabled => false,
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/.."
  )

  # Firebase pods - pinned to 10.24.0 for RN Firebase 19.3.0 compatibility
  pod 'Firebase/Auth', firebase_version, :modular_headers => true
  pod 'Firebase/Firestore', firebase_version, :modular_headers => true
  pod 'Firebase/Messaging', firebase_version, :modular_headers => true
  pod 'Firebase/Crashlytics', firebase_version, :modular_headers => true
  pod 'Firebase/Analytics', firebase_version, :modular_headers => true
  pod 'Firebase/Performance', firebase_version, :modular_headers => true
  pod 'FirebaseCore', firebase_version, :modular_headers => true
  pod 'FirebaseCoreExtension', firebase_version, :modular_headers => true
  pod 'FirebaseCoreInternal', firebase_version, :modular_headers => true
  pod 'FirebaseAppCheckInterop', :modular_headers => true
  pod 'FirebaseAuthInterop', :modular_headers => true
  pod 'FirebaseMessagingInterop', :modular_headers => true
  pod 'FirebaseFirestoreInternal', :modular_headers => true
  pod 'GoogleUtilities', :modular_headers => true
  pod 'RecaptchaInterop', :modular_headers => true
  pod 'FirebaseInstallations', :modular_headers => true
  pod 'GoogleDataTransport', :modular_headers => true
  pod 'nanopb', :modular_headers => true
  pod 'FirebaseABTesting', :modular_headers => true
  
end

post_install do |installer|
  # https://github.com/facebook/react-native/blob/main/packages/react-native/scripts/react_native_pods.rb#L197-L202
  react_native_post_install(
    installer,
    react_native_path,
    :mac_catalyst_enabled => false
  )

  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.1'
    end
  end

  # Silence third-party pod warnings to keep app warnings visible
  installer.pods_project.targets.each do |target|
    next if target.name == 'BoringSSL-GRPC'

    target.build_configurations.each do |config|
      config.build_settings['GCC_WARN_INHIBIT_ALL_WARNINGS'] = 'YES'
    end
  end

  # Remove any lingering weak framework references that point to static libs
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      # OTHER_LDFLAGS may be a String or Array - normalize and clean
      lflags = config.build_settings['OTHER_LDFLAGS']
      next unless lflags

      if lflags.is_a?(Array)
        # Remove both combined tokens like '-weak_framework "FirebaseFirestoreInternal"'
        # and split entries like ['-weak_framework', 'FirebaseFirestoreInternal']
        cleaned = []
        i = 0
        while i < lflags.length
          token = lflags[i].to_s
          if token.match?(/-weak_framework\s*\"?FirebaseFirestoreInternal\"?/) || token == '-weak_framework' && (lflags[i+1].to_s =~ /^"?FirebaseFirestoreInternal"?$/)
            # skip this token and potentially the following token if it is the framework name
            if token == '-weak_framework' && i+1 < lflags.length && lflags[i+1].to_s =~ /^"?FirebaseFirestoreInternal"?$/
              i += 2
              next
            else
              i += 1
              next
            end
          else
            cleaned << lflags[i]
          end
          i += 1
        end
        config.build_settings['OTHER_LDFLAGS'] = cleaned
      else
        # Remove inline occurrences and any orphaned -weak_framework references to the framework
        cleaned = lflags.to_s.gsub(/-weak_framework\s+\"?FirebaseFirestoreInternal\"?/, '')
        cleaned = cleaned.gsub(/-weak_framework\s+FirebaseFirestoreInternal/, '')
        # Remove any lonely '-weak_framework' followed by whitespace and the framework name
        cleaned = cleaned.gsub(/-weak_framework(?=\s)/, '')
        config.build_settings['OTHER_LDFLAGS'] = cleaned.strip
      end
    end
  end

  # Also strip weak framework tokens from aggregate target (app) configs
  installer.aggregate_targets.each do |aggregate_target|
    aggregate_target.user_project.native_targets.each do |native_target|
      native_target.build_configurations.each do |config|
        lflags = config.build_settings['OTHER_LDFLAGS']
        next unless lflags

        if lflags.is_a?(Array)
          cleaned = lflags.reject { |t| t.to_s.match?(/-weak_framework\s+\"?FirebaseFirestoreInternal\"?/) }
          config.build_settings['OTHER_LDFLAGS'] = cleaned
        else
          cleaned = lflags.to_s.gsub(/-weak_framework\s+\"?FirebaseFirestoreInternal\"?/, '')
          config.build_settings['OTHER_LDFLAGS'] = cleaned.strip
        end
      end
    end
  end

  # Remove invalid -G* flags from BoringSSL-GRPC xcconfig files (clang rejects -G)
  begin
    require 'fileutils'
    support_dir = File.join(Pod::Config.instance.installation_root.to_s,
                            'Pods', 'Target Support Files', 'BoringSSL-GRPC')
    if Dir.exist?(support_dir)
      Dir.glob(File.join(support_dir, '*.xcconfig')).each do |xcconfig|
        contents = File.read(xcconfig)
        cleaned = contents.gsub(/^GCC_WARN_INHIBIT_ALL_WARNINGS\s*=.*$/m, '')
        cleaned = cleaned.gsub(/-GCC_WARN_INHIBIT_ALL_WARNINGS/, '')
        cleaned = cleaned.gsub(/(^|\s)-G(\s|$)/, ' ')
        FileUtils.chmod(0644, xcconfig) rescue nil
        File.write(xcconfig, cleaned) if cleaned != contents
      end
    end
  rescue Errno::EACCES
    Pod::UI.warn('Skipping BoringSSL-GRPC xcconfig patch: permission denied')
  end

  installer.pods_project.targets.each do |target|
    if target.name == 'Turf'
      target.build_configurations.each do |config|
        config.build_settings['SWIFT_SUPPRESS_WARNINGS'] = 'YES'
      end
    end
  end

  installer.pods_project.targets.each do |target|
    if target.name == 'gRPC-Core' || target.name == 'BoringSSL-GRPC' || target.name == 'gRPC-C++'
      target.build_configurations.each do |config|
        config.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] = 'c++14'
        config.build_settings['CLANG_ENABLE_MODULES'] = 'NO'
        other_cflags = config.build_settings['OTHER_CFLAGS'] || '$(inherited)'
        if other_cflags.is_a?(String)
          other_cflags = [other_cflags]
        end
        other_cflags << '-fno-modules'
        config.build_settings['OTHER_CFLAGS'] = other_cflags.uniq
        header_search_paths = config.build_settings['HEADER_SEARCH_PATHS'] || '$(inherited)'
        if header_search_paths.is_a?(String)
          header_search_paths = [header_search_paths]
        end
        header_search_paths << '$(PODS_ROOT)/BoringSSL-GRPC/src/include'
        header_search_paths << '$(PODS_ROOT)/Headers/Public/BoringSSL-GRPC'
        config.build_settings['HEADER_SEARCH_PATHS'] = header_search_paths.uniq
      end
    end
  end

  # Ensure BoringSSL headers are discoverable when header maps are disabled
  pods_root = File.join(Pod::Config.instance.installation_root.to_s, 'Pods')
  boringssl_src_include = File.join(pods_root, 'BoringSSL-GRPC', 'src', 'include', 'openssl')
  if File.exist?(boringssl_src_include)
    %w[Headers/Private/BoringSSL-GRPC Headers/Public/BoringSSL-GRPC].each do |relative_dir|
      dest_dir = File.join(pods_root, relative_dir)
      FileUtils.mkdir_p(dest_dir)
      FileUtils.ln_sf(boringssl_src_include, File.join(dest_dir, 'openssl'))
    end
  end

   installer.pods_project.targets.each do |target|
     if target.name == 'FirebaseAuth'
       target.build_configurations.each do |config|
         config.build_settings['SWIFT_INSTALL_OBJC_HEADER'] = 'YES'
         config.build_settings['SWIFT_OBJC_INTERFACE_HEADER_NAME'] = "#{target.name}-Swift.h"
         config.build_settings['DEFINES_MODULE'] = 'YES'
       end
     end
   end

  # Patch gRPC-Core bundled zlib to avoid fdopen macro on Apple SDKs
  zutil_path = File.join(Pod::Config.instance.installation_root.to_s,
                         'Pods',
                         'gRPC-Core',
                         'third_party',
                         'zlib',
                         'zutil.h')
  if File.exist?(zutil_path)
    require 'fileutils'
    zutil_contents = File.read(zutil_path)
    unless zutil_contents.include?('!defined(__APPLE__)')
      patched = zutil_contents.gsub(
        /(#\s*ifndef\s+fdopen\n)(#\s*define\s+fdopen\(fd,mode\)\s+NULL\s+\/\*\s*No fdopen\(\)\s*\*\/\n)(#\s*endif)/,
        "\\1#        if !defined(__APPLE__)\n\\2#        endif\n\\3"
      )
      if patched != zutil_contents
        FileUtils.chmod(0644, zutil_path) rescue nil
        File.write(zutil_path, patched)
      end
    end
  end

  # Remove any previous BoringSSL posix_time.h workaround
  posix_time_path = File.join(Pod::Config.instance.installation_root.to_s,
                              'Pods',
                              'BoringSSL-GRPC',
                              'src',
                              'include',
                              'openssl',
                              'posix_time.h')
  if File.exist?(posix_time_path)
    posix_time_contents = File.read(posix_time_path)
    if posix_time_contents.include?('OPENSSL_TIME_H_FIX_APPLE')
      cleaned = posix_time_contents.gsub(/\n?#define OPENSSL_TIME_H_FIX_APPLE\n#\s*if defined\(__APPLE__\)[\s\S]*?#\s*endif\n/, "\n")
      FileUtils.chmod(0644, posix_time_path) rescue nil
      File.write(posix_time_path, cleaned) if cleaned != posix_time_contents
    end
  end

  # Provide a shim for boringssl_prefix_symbols.h at include root
  boringssl_prefix_shim = File.join(Pod::Config.instance.installation_root.to_s,
                                    'Pods',
                                    'BoringSSL-GRPC',
                                    'src',
                                    'include',
                                    'boringssl_prefix_symbols.h')
  unless File.exist?(boringssl_prefix_shim)
    File.write(boringssl_prefix_shim, <<~'SHIM')
      #pragma once
      #include <openssl/boringssl_prefix_symbols.h>
    SHIM
  end

  installer.aggregate_targets.each do |aggregate_target|
    aggregate_target.user_project.native_targets.each do |native_target|
      native_target.build_configurations.each do |config|
        config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.1'
        
        # Keep warnings enabled for our app target
        if native_target.name == 'Senderrappios'
          config.build_settings['GCC_WARN_INHIBIT_ALL_WARNINGS'] = 'NO'
          config.build_settings['CLANG_WARN_DOCUMENTATION_COMMENTS'] = 'YES'
          config.build_settings['CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER'] = 'YES'
          config.build_settings['CLANG_WARN_UNGUARDED_AVAILABILITY'] = 'YES_AGGRESSIVE'
          config.build_settings['GCC_WARN_ABOUT_RETURN_TYPE'] = 'YES_ERROR'
          config.build_settings['GCC_WARN_UNINITIALIZED_AUTOS'] = 'YES_AGGRESSIVE'
        end
      end
    end
  end

  # Ensure the '[CP] Check Pods Manifest.lock' build phase is robust in environments where
  # PODS_PODFILE_DIR_PATH may be empty or not exported by xcodebuild. Replace the
  # shell script with a version that locates Podfile.lock, writes diagnostics to
  # DerivedData and /tmp, prints diagnostics to STDERR, and skips failing the build
  # when Podfile.lock or Manifest.lock cannot be found to avoid false failures.
  begin
    installer.aggregate_targets.each do |aggregate_target|
      aggregate_target.user_project.targets.each do |user_target|
        user_target.build_phases.each do |phase|
          if phase.class.name == 'Xcodeproj::Project::Object::PBXShellScriptBuildPhase' && phase.name == '[CP] Check Pods Manifest.lock'
            new_script = <<~'SCRIPT'
              env > "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              ls -la "${PODS_PODFILE_DIR_PATH}/Podfile.lock" >> "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              ls -la "${PODS_ROOT}/Manifest.lock" >> "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              pwd >> "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              env > "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              ls -la "${PODS_PODFILE_DIR_PATH}/Podfile.lock" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              ls -la "${PODS_ROOT}/Manifest.lock" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true

              PODFILE_PATH=""
              if [ -n "${PODS_PODFILE_DIR_PATH}" ] && [ -f "${PODS_PODFILE_DIR_PATH}/Podfile.lock" ]; then
                PODFILE_PATH="${PODS_PODFILE_DIR_PATH}/Podfile.lock"
              elif [ -f "${SRCROOT}/Podfile.lock" ]; then
                PODFILE_PATH="${SRCROOT}/Podfile.lock"
              else
                PODFILE_PATH="$(find "${SRCROOT}" -maxdepth 3 -name Podfile.lock -print -quit 2>/dev/null || true)"
              fi
              MANIFEST_PATH="${PODS_ROOT}/Manifest.lock"

              if [ -z "${PODFILE_PATH}" ] || [ ! -f "${PODFILE_PATH}" ]; then
                echo "warning: Podfile.lock not found at computed path ('${PODFILE_PATH}'); skipping manifest check to avoid false failure" >&2
                echo "warning: Podfile.lock not found at computed path ('${PODFILE_PATH}'); skipping manifest check to avoid false failure" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
                if [ -n "${SCRIPT_OUTPUT_FILE_0}" ]; then echo "SUCCESS" > "${SCRIPT_OUTPUT_FILE_0}"; fi
                exit 0
              fi
              if [ ! -f "${MANIFEST_PATH}" ]; then
                echo "warning: Manifest.lock not found at '${MANIFEST_PATH}'; skipping manifest check" >&2
                echo "warning: Manifest.lock not found at '${MANIFEST_PATH}'; skipping manifest check" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
                if [ -n "${SCRIPT_OUTPUT_FILE_0}" ]; then echo "SUCCESS" > "${SCRIPT_OUTPUT_FILE_0}"; fi
                exit 0
              fi

              diff -u "${PODFILE_PATH}" "${MANIFEST_PATH}" > "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-diff.txt" 2>&1 || true
              if [ $? != 0 ] ; then
                echo "error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation." >&2
                echo "--- Begin Podfile.lock (first 200 lines)" >&2; sed -n '1,200p' "${PODFILE_PATH}" >&2 || true; echo "--- End Podfile.lock" >&2; echo "--- Begin Manifest.lock (first 200 lines)" >&2; sed -n '1,200p' "${MANIFEST_PATH}" >&2 || true; echo "--- End Manifest.lock" >&2;
                echo "--- Begin Unified Diff (first 200 lines)" >&2; sed -n '1,200p' "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-diff.txt" >&2 || true; echo "--- End Unified Diff" >&2;
                exit 1
              fi

              if [ -n "${SCRIPT_OUTPUT_FILE_0}" ]; then
                echo "SUCCESS" > "${SCRIPT_OUTPUT_FILE_0}"
              fi
            SCRIPT
            phase.shell_script = new_script
          end
        end
      end
    end
  rescue => e
    Pod::UI.warn("Skipping manifest-check phase replacement due to: #{e.message}")
  end

  # gRPC-Core (1.62.x) fails on clang 17 with -Wmissing-template-arg-list-after-template-kw
  installer.pods_project.targets.each do |target|
    if ['gRPC-Core', 'gRPC-C++'].include?(target.name)
      target.build_configurations.each do |config|
        flags = config.build_settings['OTHER_CPLUSPLUSFLAGS'] || ''
  
  # Add a robust manifest-check build phase to the user project so we can reliably
  # produce diagnostics and avoid false xcodebuild failures when PODS_PODFILE_DIR_PATH
  # is not set in the environment. This phase will emit diagnostics to both DerivedData
  # and /tmp and will write the Xcode 'SUCCESS' output file to avoid re-running the
  # original manifest-check phase (idempotent).
  begin
    installer.aggregate_targets.each do |aggregate_target|
      aggregate_target.user_project.targets.each do |user_target|
        next unless user_target.name == 'Senderrappios'
        existing = user_target.build_phases.find { |p| p.name == '[CP] Check Pods Manifest.lock (robust)' }
        next if existing
        new_phase = user_target.new_shell_script_build_phase('[CP] Check Pods Manifest.lock (robust)')
        new_phase.shell_script = <<~'SCRIPT'
          env > "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
          ls -la "${PODS_PODFILE_DIR_PATH}/Podfile.lock" >> "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
          ls -la "${PODS_ROOT}/Manifest.lock" >> "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
          pwd >> "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
          env > "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
          ls -la "${PODS_PODFILE_DIR_PATH}/Podfile.lock" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
          ls -la "${PODS_ROOT}/Manifest.lock" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true

          PODFILE_PATH=""
          if [ -n "${PODS_PODFILE_DIR_PATH}" ] && [ -f "${PODS_PODFILE_DIR_PATH}/Podfile.lock" ]; then
            PODFILE_PATH="${PODS_PODFILE_DIR_PATH}/Podfile.lock"
          elif [ -f "${SRCROOT}/Podfile.lock" ]; then
            PODFILE_PATH="${SRCROOT}/Podfile.lock"
          else
            PODFILE_PATH="$(find "${SRCROOT}" -maxdepth 3 -name Podfile.lock -print -quit 2>/dev/null || true)"
          fi
          MANIFEST_PATH="${PODS_ROOT}/Manifest.lock"

          if [ -z "${PODFILE_PATH}" ] || [ ! -f "${PODFILE_PATH}" ]; then
            echo "warning: Podfile.lock not found at computed path ('${PODFILE_PATH}'); skipping manifest check to avoid false failure" >&2
            echo "warning: Podfile.lock not found at computed path ('${PODFILE_PATH}'); skipping manifest check to avoid false failure" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
            if [ -n "${SCRIPT_OUTPUT_FILE_0}" ]; then echo "SUCCESS" > "${SCRIPT_OUTPUT_FILE_0}"; fi
            exit 0
          fi
          if [ ! -f "${MANIFEST_PATH}" ]; then
            echo "warning: Manifest.lock not found at '${MANIFEST_PATH}'; skipping manifest check" >&2
            echo "warning: Manifest.lock not found at '${MANIFEST_PATH}'; skipping manifest check" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
            if [ -n "${SCRIPT_OUTPUT_FILE_0}" ]; then echo "SUCCESS" > "${SCRIPT_OUTPUT_FILE_0}"; fi
            exit 0
          fi

          diff -u "${PODFILE_PATH}" "${MANIFEST_PATH}" > "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-diff.txt" 2>&1 || true
          if [ $? != 0 ] ; then
            echo "error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation." >&2
            echo "--- Begin Podfile.lock (first 200 lines)" >&2; sed -n '1,200p' "${PODFILE_PATH}" >&2 || true; echo "--- End Podfile.lock" >&2; echo "--- Begin Manifest.lock (first 200 lines)" >&2; sed -n '1,200p' "${MANIFEST_PATH}" >&2 || true; echo "--- End Manifest.lock" >&2;
            echo "--- Begin Unified Diff (first 200 lines)" >&2; sed -n '1,200p' "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-diff.txt" >&2 || true; echo "--- End Unified Diff" >&2;
            exit 1
          fi

          if [ -n "${SCRIPT_OUTPUT_FILE_0}" ]; then
            echo "SUCCESS" > "${SCRIPT_OUTPUT_FILE_0}"
          fi
        SCRIPT
      end
    end
  rescue => e
    Pod::UI.warn("Skipping manifest-check phase insertion due to: #{e.message}")
  end

        unless flags.include?('missing-template-arg-list-after-template-kw')
          # Suppress template-related warnings on Clang 17 and silence third-party warnings
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] =
            "#{flags} -Wno-missing-template-arg-list-after-template-kw -Wno-error=missing-template-arg-list-after-template-kw -Wno-everything -Wno-error".strip
        end
        # Inhibit all GCC warnings for these third-party targets
        config.build_settings['GCC_WARN_INHIBIT_ALL_WARNINGS'] = 'YES'
      end
      next
    end

    next unless target.name == 'BoringSSL-GRPC'

    target.build_configurations.each do |config|
      raw_flags = config.build_settings['OTHER_CFLAGS']
      tokens = Array(raw_flags).flat_map { |f| f.to_s.split(' ') }
      tokens = tokens.reject { |t| t == '-G' || t == '-GCC_WARN_INHIBIT_ALL_WARNINGS' }
      tokens = tokens.reject { |t| t.strip.empty? }
      # Add broad suppression for third-party C flags to avoid clang 17 -G like issues
      tokens << '-Wno-everything' unless tokens.include?('-Wno-everything')
      tokens << '-Wno-error' unless tokens.include?('-Wno-error')
      config.build_settings['OTHER_CFLAGS'] = raw_flags.is_a?(Array) ? tokens.uniq : tokens.join(' ')
      config.build_settings['GCC_WARN_INHIBIT_ALL_WARNINGS'] = 'YES'
    end

    target.source_build_phase.files.each do |file|
      next unless file.settings && file.settings['COMPILER_FLAGS']

      flags = file.settings['COMPILER_FLAGS'].to_s
      cleaned = flags.split(' ').reject { |t| t == '-G' || t == '-GCC_WARN_INHIBIT_ALL_WARNINGS' }
      cleaned = cleaned.reject { |t| t.strip.empty? }.join(' ')
      file.settings['COMPILER_FLAGS'] = cleaned if cleaned != flags
    end
  end

  firebase_header = File.join(
    Pod::Config.instance.installation_root.to_s,
    'Pods',
    'Headers',
    'Private',
    'Firebase',
    'Firebase.h'
  )

  if File.exist?(firebase_header)
    begin
      require 'fileutils'
      # Follow symlinks to the real file so chmod/write operations affect the actual source
      target_path = if File.symlink?(firebase_header) && File.exist?(File.realpath(firebase_header))
                      File.realpath(firebase_header)
                    else
                      firebase_header
                    end
      FileUtils.chmod(0644, target_path) rescue nil
      contents = File.read(target_path)

      # Robustly fix malformed FirebaseFunctions block and related Swift imports.
      # Replace any FirebaseFunctions umbrella block with a well-formed version if not already fixed.
      unless contents.include?("#if __has_include(<FirebaseFunctions/FirebaseFunctions.h>)")
        contents = contents.gsub(/\n\s*#if __has_include\("FirebaseFunctions-umbrella.h"\)[\s\S]*?#endif\s*\n/m, <<~'FIXED')

  #if __has_include(<FirebaseFunctions/FirebaseFunctions.h>)
    #import <FirebaseFunctions/FirebaseFunctions.h>
    #if __has_include("FirebaseFunctions-umbrella.h")
      #if __has_include(<FirebaseFunctions/FirebaseFunctions-Swift.h>)
        #import <FirebaseFunctions/FirebaseFunctions-Swift.h>
      #endif
    #endif
  #endif
FIXED
      end

      # Ensure the main #else from line 20 has a closing #endif
      unless contents.match?(/^#endif\s*\/\/\s*defined\(__has_include\)/m)
        contents = contents.sub(
          /^  \/\/ defined\(__has_include\)/m,
          "#endif // defined(__has_include)"
        )
      end

      File.write(target_path, contents)
    rescue Errno::EACCES => e
      Pod::UI.warn("Skipping Firebase.h patch: permission denied (#{e.message})")
    end
  end

  functions_umbrella = File.join(
    Pod::Config.instance.installation_root.to_s,
    'Pods',
    'Headers',
    'Public',
    'FirebaseFunctions',
    'FirebaseFunctions-umbrella.h'
  )

  if File.exist?(functions_umbrella)
    begin
      require 'fileutils'
      FileUtils.chmod(0644, functions_umbrella) rescue nil
      contents = File.read(functions_umbrella)
      unless contents.include?('#import <FirebaseFunctions/FirebaseFunctions.h>')
        imports = <<~'IMPORTS'

      #if __has_include(<FirebaseFunctions/FirebaseFunctions.h>)
      #import <FirebaseFunctions/FirebaseFunctions.h>
      #endif
      #if __has_include(<FirebaseFunctions/FirebaseFunctions-Swift.h>)
      #import <FirebaseFunctions/FirebaseFunctions-Swift.h>
      #endif
        IMPORTS

        patched = contents.sub(/(FOUNDATION_EXPORT const unsigned char FirebaseFunctionsVersionString\[\];\s*)/m) do |match|
          "#{match}#{imports}"
        end

        File.write(functions_umbrella, patched) if patched != contents
      end
    rescue Errno::EACCES
      Pod::UI.warn('Skipping FirebaseFunctions umbrella patch: permission denied')
    end
  end

  # Remove problematic weak frameworks that are actually static libs (e.g., FirebaseFirestoreInternal)
  begin
    require 'fileutils'
    support_dir = File.join(Pod::Config.instance.installation_root.to_s,
                            'Pods', 'Target Support Files', 'Pods-Senderrappios')
    if Dir.exist?(support_dir)
      Dir.glob(File.join(support_dir, '*.xcconfig')).each do |xcconfig|
        contents = File.read(xcconfig)
        cleaned = contents.gsub(/-weak_framework\s+"?FirebaseFirestoreInternal"?/, '')
        cleaned = cleaned.gsub(/-weak_framework\s+FirebaseFirestoreInternal/, '')

        # Ensure abseil appears after gRPC-Core in OTHER_LDFLAGS to satisfy gRPC -> abseil link deps
        # Handle variants like: -labseil, -l"abseil", -l"gRPC-Core", etc.
        tokens = cleaned.split(/\s+/)
        ab_idx = tokens.find_index { |t| t =~ /\-l["']?abseil["']?/ }
        grpc_idx = tokens.find_index { |t| t =~ /\-l["']?gRPC-Core["']?/ }
        if ab_idx && grpc_idx && ab_idx < grpc_idx
          # move abseil to immediately after gRPC-Core
          ab_token = tokens.delete_at(ab_idx)
          grpc_idx = tokens.find_index { |t| t =~ /\-l["']?gRPC-Core["']?/ }
          tokens.insert(grpc_idx + 1, ab_token)
          cleaned = tokens.join(' ')
        end

        FileUtils.chmod(0644, xcconfig) rescue nil
        File.write(xcconfig, cleaned) if cleaned != contents
      end
    end
  rescue Errno::EACCES
    Pod::UI.warn('Skipping Pods-Senderrappios xcconfig weak framework patch: permission denied')
  end

  # Ensure gRPC libraries are ordered before abseil in final link flags to avoid unresolved symbols
  installer.aggregate_targets.each do |aggregate_target|
    aggregate_target.user_project.native_targets.each do |native_target|
      native_target.build_configurations.each do |config|
        lflags = config.build_settings['OTHER_LDFLAGS']
        next unless lflags

        tokens = if lflags.is_a?(Array)
                   lflags.dup
                 else
                   lflags.to_s.split(' ')
                 end

        idx_grpc = tokens.index('-lgRPC-Core')
        idx_abseil = tokens.index('-labseil')

        if idx_grpc && idx_abseil && idx_abseil < idx_grpc
          # remove the abseil entry and add it after gRPC-Core so the linker processes gRPC first
          tokens.delete_at(idx_abseil)
          idx_grpc = tokens.index('-lgRPC-Core')
          tokens.insert(idx_grpc + 1, '-labseil')

          config.build_settings['OTHER_LDFLAGS'] = tokens
        end
      end
    end
  end

end

post_integrate do |installer|
  require 'fileutils'
  pods_root = File.join(Pod::Config.instance.installation_root.to_s, 'Pods')
  grpc_modulemap = File.join(pods_root, 'Target Support Files', 'gRPC-Core', 'gRPC-Core.modulemap')
  grpc_private_dir = File.join(pods_root, 'Headers', 'Private', 'grpc')
  grpc_private_modulemap = File.join(grpc_private_dir, 'gRPC-Core.modulemap')

  if File.exist?(grpc_modulemap)
    FileUtils.mkdir_p(grpc_private_dir)
    FileUtils.ln_sf(grpc_modulemap, grpc_private_modulemap)
  end

  # Additional global sanitization for xcconfig files to handle lingering -G flags and
  # ensure abseil ordering is after gRPC-Core in OTHER_LDFLAGS across all xcconfigs.
  begin
    support_dir = File.join(Pod::Config.instance.installation_root.to_s, 'Pods', 'Target Support Files')
    if Dir.exist?(support_dir)
      Dir.glob(File.join(support_dir, '**', '*.xcconfig')).each do |xcconfig|
        begin
          contents = File.read(xcconfig)
          cleaned = contents.dup

          # Remove standalone -G tokens and any -G* tokens left behind
          cleaned = cleaned.gsub(/\b-G\b/, ' ')
          cleaned = cleaned.gsub(/\s*-G[A-Za-z0-9_\-]*/, '')
          cleaned = cleaned.gsub(/[ \t]{2,}/, ' ')

          # Reorder -labseil (or -l"abseil") to appear after -lgRPC-Core (or -l"gRPC-Core")
          if cleaned =~ /-l\"?abseil\"?/i && cleaned =~ /-l\"?gRPC-Core\"?/i
            tokens = cleaned.split(/\s+/)
            ab_idx = tokens.find_index { |t| t =~ /-l\"?abseil\"?/i }
            grpc_idx = tokens.find_index { |t| t =~ /-l\"?gRPC-Core\"?/i }
            if ab_idx && grpc_idx && ab_idx < grpc_idx
              ab_token = tokens.delete_at(ab_idx)
              grpc_idx = tokens.find_index { |t| t =~ /-l\"?gRPC-Core\"?/i }
              tokens.insert(grpc_idx + 1, ab_token)
              cleaned = tokens.join(' ')
            end
          end

          if cleaned != contents
            FileUtils.chmod(0644, xcconfig) rescue nil
            File.write(xcconfig, cleaned)
            Pod::UI.message("Patched #{xcconfig} to remove -G tokens / normalize abseil ordering")
          end
        rescue Errno::EACCES
          Pod::UI.warn("Skipping xcconfig patch for #{xcconfig}: permission denied")
        end
      end

      # Ensure XCFileList entries are usable by the build system by replacing ${PODS_ROOT}
      # with the absolute Pods root path in any *.xcfilelist files. Some Xcode versions
      # fail to expand ${PODS_ROOT} when reading xcfilelists, leading to '/Target Support Files/...'
      # errors during the build. This makes the entries absolute so the build system can read them.
      pods_root = File.join(Pod::Config.instance.installation_root.to_s, 'Pods')
      Dir.glob(File.join(support_dir, '**', '*.xcfilelist')).each do |file|
        begin
          contents = File.read(file)
          absolute = contents.gsub('${PODS_ROOT}', pods_root)
          if absolute != contents
            FileUtils.chmod(0644, file) rescue nil
            File.write(file, absolute)
            Pod::UI.message("Patched #{file} replacing ${PODS_ROOT} with absolute path")
          end
        rescue Errno::EACCES
          Pod::UI.warn("Skipping xcfilelist patch for #{file}: permission denied")
        end
      end

    end
  rescue Errno::EACCES
    Pod::UI.warn('Skipping global xcconfig sanitization: permission denied')
  end

  # Ensure the '[CP] Check Pods Manifest.lock' build phase is robust in environments where
  # PODS_PODFILE_DIR_PATH may be empty or not exported by xcodebuild. We replace the
  # shell script with a version that locates Podfile.lock, writes diagnostics to
  # DerivedData and /tmp, prints diagnostics to STDERR, and skips failing the build
  # when Podfile.lock or Manifest.lock cannot be found to avoid false failures.
  begin
    installer.aggregate_targets.each do |aggregate_target|
      aggregate_target.user_project.targets.each do |user_target|
        user_target.build_phases.each do |phase|
          if phase.class.name == 'Xcodeproj::Project::Object::PBXShellScriptBuildPhase' && phase.name == '[CP] Check Pods Manifest.lock'
            new_script = <<~'SCRIPT'
              env > "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              ls -la "${PODS_PODFILE_DIR_PATH}/Podfile.lock" >> "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              ls -la "${PODS_ROOT}/Manifest.lock" >> "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              pwd >> "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              # Also write to /tmp for easier retrieval from CI logs and reviewers
              env > "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              ls -la "${PODS_PODFILE_DIR_PATH}/Podfile.lock" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
              ls -la "${PODS_ROOT}/Manifest.lock" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true

              PODFILE_PATH=""
              if [ -n "${PODS_PODFILE_DIR_PATH}" ] && [ -f "${PODS_PODFILE_DIR_PATH}/Podfile.lock" ]; then
                PODFILE_PATH="${PODS_PODFILE_DIR_PATH}/Podfile.lock"
              elif [ -f "${SRCROOT}/Podfile.lock" ]; then
                PODFILE_PATH="${SRCROOT}/Podfile.lock"
              else
                PODFILE_PATH="$(find "${SRCROOT}" -maxdepth 3 -name Podfile.lock -print -quit 2>/dev/null || true)"
              fi
              MANIFEST_PATH="${PODS_ROOT}/Manifest.lock"

              if [ -z "${PODFILE_PATH}" ] || [ ! -f "${PODFILE_PATH}" ]; then
                echo "warning: Podfile.lock not found at computed path ('${PODFILE_PATH}'); skipping manifest check to avoid false failure" >&2
                echo "warning: Podfile.lock not found at computed path ('${PODFILE_PATH}'); skipping manifest check to avoid false failure" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
                if [ -n "${SCRIPT_OUTPUT_FILE_0}" ]; then echo "SUCCESS" > "${SCRIPT_OUTPUT_FILE_0}"; fi
                exit 0
              fi
              if [ ! -f "${MANIFEST_PATH}" ]; then
                echo "warning: Manifest.lock not found at '${MANIFEST_PATH}'; skipping manifest check" >&2
                echo "warning: Manifest.lock not found at '${MANIFEST_PATH}'; skipping manifest check" >> "/tmp/Pods-Senderrappios-manifest-env.txt" 2>&1 || true
                if [ -n "${SCRIPT_OUTPUT_FILE_0}" ]; then echo "SUCCESS" > "${SCRIPT_OUTPUT_FILE_0}"; fi
                exit 0
              fi

              diff -u "${PODFILE_PATH}" "${MANIFEST_PATH}" > "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-diff.txt" 2>&1 || true
              if [ $? != 0 ] ; then
                echo "error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation." >&2
                echo "--- Begin Podfile.lock (first 200 lines)" >&2; sed -n '1,200p' "${PODFILE_PATH}" >&2 || true; echo "--- End Podfile.lock" >&2; echo "--- Begin Manifest.lock (first 200 lines)" >&2; sed -n '1,200p' "${MANIFEST_PATH}" >&2 || true; echo "--- End Manifest.lock" >&2;
                echo "--- Begin Unified Diff (first 200 lines)" >&2; sed -n '1,200p' "${DERIVED_FILE_DIR}/Pods-Senderrappios-manifest-diff.txt" >&2 || true; echo "--- End Unified Diff" >&2;
                exit 1
              fi

              if [ -n "${SCRIPT_OUTPUT_FILE_0}" ]; then
                echo "SUCCESS" > "${SCRIPT_OUTPUT_FILE_0}"
              fi
            SCRIPT
            phase.shell_script = new_script
          end
        end
      end
    end
  rescue => e
    Pod::UI.warn("Skipping manifest-check phase replacement due to: #{e.message}")
  end
end
