/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/v2/courier/setup/page",{

/***/ "(app-pages-browser)/../../node_modules/.pnpm/ngeohash@0.6.3/node_modules/ngeohash/main.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/.pnpm/ngeohash@0.6.3/node_modules/ngeohash/main.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\nvar ENCODE_AUTO = 'auto';\n\nvar MIN_LAT = -90;\nvar MAX_LAT = 90;\nvar MIN_LON = -180;\nvar MAX_LON = 180;\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n\n  var chars = [],\n  bits = 0,\n  bitsTotal = 0,\n  hash_value = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var bitsTotal = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid,\n  combinedBits = 0;\n\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = (hashValue >> bits) & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON;\n\n  var latBit = 0, lonBit = 0;\n  var step = bitDepth / 2;\n\n  for (var i = 0; i < step; i++) {\n\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\n\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    }\n    else {\n      minLat = (maxLat + minLat) / 2;\n    }\n\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    }\n    else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\nfunction get_bit(bits, position) {\n  return (bits / Math.pow(2, position)) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n      error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude\n    + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude\n    + direction[1] * lonLat.error.longitude * 2;\n  neighborLon = ensure_valid_lon(neighborLon);\n  neighborLat = ensure_valid_lat(neighborLat);\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function (hash_int, direction, bitDepth) {\n    bitDepth = bitDepth || 52;\n    var lonlat = decode_int(hash_int, bitDepth);\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function (hash_string) {\n\n    var hashstringLength = hash_string.length;\n\n    var lonlat = decode(hash_string);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashList = [\n                            encodeNeighbor(1,0),\n                            encodeNeighbor(1,1),\n                            encodeNeighbor(0,1),\n                            encodeNeighbor(-1,1),\n                            encodeNeighbor(-1,0),\n                            encodeNeighbor(-1,-1),\n                            encodeNeighbor(0,-1),\n                            encodeNeighbor(1,-1)\n                            ];\n\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\n    }\n\n    return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function(hash_int, bitDepth){\n\n    bitDepth = bitDepth || 52;\n\n    var lonlat = decode_int(hash_int, bitDepth);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashIntList = [\n                               encodeNeighbor_int(1,0),\n                               encodeNeighbor_int(1,1),\n                               encodeNeighbor_int(0,1),\n                               encodeNeighbor_int(-1,1),\n                               encodeNeighbor_int(-1,0),\n                               encodeNeighbor_int(-1,-1),\n                               encodeNeighbor_int(0,-1),\n                               encodeNeighbor_int(1,-1)\n                               ];\n\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n    }\n\n    return neighborHashIntList;\n};\n\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n  var latLon = decode(hashSouthWest);\n\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n  var hashList = [];\n\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\n    bitDepth = bitDepth || 52;\n\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n\n    var latlon = decode_int(hashSouthWest, bitDepth);\n\n    var perLat = latlon.error.latitude * 2;\n    var perLon = latlon.error.longitude * 2;\n\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\n\n    var hashList = [];\n\n    for(var lat = 0; lat <= latStep; lat++){\n        for(var lon = 0; lon <= lonStep; lon++){\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\n        }\n    }\n\n  return hashList;\n};\n\nfunction ensure_valid_lon(lon) {\n  if (lon > MAX_LON)\n    return MIN_LON + lon % MAX_LON;\n  if (lon < MIN_LON)\n    return MAX_LON + lon % MAX_LON;\n  return lon;\n};\n\nfunction ensure_valid_lat(lat) {\n  if (lat > MAX_LAT)\n    return MAX_LAT;\n  if (lat < MIN_LAT)\n    return MIN_LAT;\n  return lat;\n};\n\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\n\nmodule.exports = geohash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmdlb2hhc2hAMC42LjMvbm9kZV9tb2R1bGVzL25nZW9oYXNoL21haW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvcGFwYWRldi9kZXYvYXBwcy9nb3NlbmRlcnIvbm9kZV9tb2R1bGVzLy5wbnBtL25nZW9oYXNoQDAuNi4zL25vZGVfbW9kdWxlcy9uZ2VvaGFzaC9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDExLCBTdW4gTmluZy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksXG4gKiBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICovXG5cbnZhciBCQVNFMzJfQ09ERVMgPSBcIjAxMjM0NTY3ODliY2RlZmdoamttbnBxcnN0dXZ3eHl6XCI7XG52YXIgQkFTRTMyX0NPREVTX0RJQ1QgPSB7fTtcbmZvciAodmFyIGkgPSAwOyBpIDwgQkFTRTMyX0NPREVTLmxlbmd0aDsgaSsrKSB7XG4gIEJBU0UzMl9DT0RFU19ESUNUW0JBU0UzMl9DT0RFUy5jaGFyQXQoaSldID0gaTtcbn1cblxudmFyIEVOQ09ERV9BVVRPID0gJ2F1dG8nO1xuXG52YXIgTUlOX0xBVCA9IC05MDtcbnZhciBNQVhfTEFUID0gOTA7XG52YXIgTUlOX0xPTiA9IC0xODA7XG52YXIgTUFYX0xPTiA9IDE4MDtcbi8qKlxuICogU2lnbmlmaWNhbnQgRmlndXJlIEhhc2ggTGVuZ3RoXG4gKlxuICogVGhpcyBpcyBhIHF1aWNrIGFuZCBkaXJ0eSBsb29rdXAgdG8gZmlndXJlIG91dCBob3cgbG9uZyBvdXIgaGFzaFxuICogc2hvdWxkIGJlIGluIG9yZGVyIHRvIGd1YXJhbnRlZSBhIGNlcnRhaW4gYW1vdW50IG9mIHRyYWlsaW5nXG4gKiBzaWduaWZpY2FudCBmaWd1cmVzLiBUaGlzIHdhcyBjYWxjdWxhdGVkIGJ5IGRldGVybWluaW5nIHRoZSBlcnJvcjpcbiAqIDQ1LzJeKG4tMSkgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIGJpdHMgZm9yIGEgbGF0aXR1ZGUgb3JcbiAqIGxvbmdpdHVkZS4gS2V5IGlzICMgb2YgZGVzaXJlZCBzaWcgZmlncywgdmFsdWUgaXMgbWluaW11bSBsZW5ndGggb2ZcbiAqIHRoZSBnZW9oYXNoLlxuICogQHR5cGUgQXJyYXlcbiAqL1xuLy8gICAgIERlc2lyZWQgc2lnIGZpZ3M6ICAwICAxICAyICAzICA0ICAgNSAgIDYgICA3ICAgOCAgIDkgIDEwXG52YXIgU0lHRklHX0hBU0hfTEVOR1RIID0gWzAsIDUsIDcsIDgsIDExLCAxMiwgMTMsIDE1LCAxNiwgMTcsIDE4XTtcbi8qKlxuICogRW5jb2RlXG4gKlxuICogQ3JlYXRlIGEgR2VvaGFzaCBvdXQgb2YgYSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIHRoYXQgaXNcbiAqIGBudW1iZXJPZkNoYXJzYCBsb25nLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbGF0aXR1ZGVcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbG9uZ2l0dWRlXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyT2ZDaGFyc1xuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChsYXRpdHVkZSwgbG9uZ2l0dWRlLCBudW1iZXJPZkNoYXJzKSB7XG4gIGlmIChudW1iZXJPZkNoYXJzID09PSBFTkNPREVfQVVUTykge1xuICAgIGlmICh0eXBlb2YobGF0aXR1ZGUpID09PSAnbnVtYmVyJyB8fCB0eXBlb2YobG9uZ2l0dWRlKSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIG5vdGF0aW9uIHJlcXVpcmVkIGZvciBhdXRvIHByZWNpc2lvbi4nKTtcbiAgICB9XG4gICAgdmFyIGRlY1NpZ0ZpZ3NMYXQgPSBsYXRpdHVkZS5zcGxpdCgnLicpWzFdLmxlbmd0aDtcbiAgICB2YXIgZGVjU2lnRmlnc0xvbmcgPSBsb25naXR1ZGUuc3BsaXQoJy4nKVsxXS5sZW5ndGg7XG4gICAgdmFyIG51bWJlck9mU2lnRmlncyA9IE1hdGgubWF4KGRlY1NpZ0ZpZ3NMYXQsIGRlY1NpZ0ZpZ3NMb25nKTtcbiAgICBudW1iZXJPZkNoYXJzID0gU0lHRklHX0hBU0hfTEVOR1RIW251bWJlck9mU2lnRmlnc107XG4gIH0gZWxzZSBpZiAobnVtYmVyT2ZDaGFycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnVtYmVyT2ZDaGFycyA9IDk7XG4gIH1cblxuICB2YXIgY2hhcnMgPSBbXSxcbiAgYml0cyA9IDAsXG4gIGJpdHNUb3RhbCA9IDAsXG4gIGhhc2hfdmFsdWUgPSAwLFxuICBtYXhMYXQgPSBNQVhfTEFULFxuICBtaW5MYXQgPSBNSU5fTEFULFxuICBtYXhMb24gPSBNQVhfTE9OLFxuICBtaW5Mb24gPSBNSU5fTE9OLFxuICBtaWQ7XG4gIHdoaWxlIChjaGFycy5sZW5ndGggPCBudW1iZXJPZkNoYXJzKSB7XG4gICAgaWYgKGJpdHNUb3RhbCAlIDIgPT09IDApIHtcbiAgICAgIG1pZCA9IChtYXhMb24gKyBtaW5Mb24pIC8gMjtcbiAgICAgIGlmIChsb25naXR1ZGUgPiBtaWQpIHtcbiAgICAgICAgaGFzaF92YWx1ZSA9IChoYXNoX3ZhbHVlIDw8IDEpICsgMTtcbiAgICAgICAgbWluTG9uID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzaF92YWx1ZSA9IChoYXNoX3ZhbHVlIDw8IDEpICsgMDtcbiAgICAgICAgbWF4TG9uID0gbWlkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtaWQgPSAobWF4TGF0ICsgbWluTGF0KSAvIDI7XG4gICAgICBpZiAobGF0aXR1ZGUgPiBtaWQpIHtcbiAgICAgICAgaGFzaF92YWx1ZSA9IChoYXNoX3ZhbHVlIDw8IDEpICsgMTtcbiAgICAgICAgbWluTGF0ID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzaF92YWx1ZSA9IChoYXNoX3ZhbHVlIDw8IDEpICsgMDtcbiAgICAgICAgbWF4TGF0ID0gbWlkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJpdHMrKztcbiAgICBiaXRzVG90YWwrKztcbiAgICBpZiAoYml0cyA9PT0gNSkge1xuICAgICAgdmFyIGNvZGUgPSBCQVNFMzJfQ09ERVNbaGFzaF92YWx1ZV07XG4gICAgICBjaGFycy5wdXNoKGNvZGUpO1xuICAgICAgYml0cyA9IDA7XG4gICAgICBoYXNoX3ZhbHVlID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgSW50ZWdlclxuICpcbiAqIENyZWF0ZSBhIEdlb2hhc2ggb3V0IG9mIGEgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSB0aGF0IGlzIG9mICdiaXREZXB0aCcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxhdGl0dWRlXG4gKiBAcGFyYW0ge051bWJlcn0gbG9uZ2l0dWRlXG4gKiBAcGFyYW0ge051bWJlcn0gYml0RGVwdGhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbnZhciBlbmNvZGVfaW50ID0gZnVuY3Rpb24gKGxhdGl0dWRlLCBsb25naXR1ZGUsIGJpdERlcHRoKSB7XG5cbiAgYml0RGVwdGggPSBiaXREZXB0aCB8fCA1MjtcblxuICB2YXIgYml0c1RvdGFsID0gMCxcbiAgbWF4TGF0ID0gTUFYX0xBVCxcbiAgbWluTGF0ID0gTUlOX0xBVCxcbiAgbWF4TG9uID0gTUFYX0xPTixcbiAgbWluTG9uID0gTUlOX0xPTixcbiAgbWlkLFxuICBjb21iaW5lZEJpdHMgPSAwO1xuXG4gIHdoaWxlIChiaXRzVG90YWwgPCBiaXREZXB0aCkge1xuICAgIGNvbWJpbmVkQml0cyAqPSAyO1xuICAgIGlmIChiaXRzVG90YWwgJSAyID09PSAwKSB7XG4gICAgICBtaWQgPSAobWF4TG9uICsgbWluTG9uKSAvIDI7XG4gICAgICBpZiAobG9uZ2l0dWRlID4gbWlkKSB7XG4gICAgICAgIGNvbWJpbmVkQml0cyArPSAxO1xuICAgICAgICBtaW5Mb24gPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhMb24gPSBtaWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pZCA9IChtYXhMYXQgKyBtaW5MYXQpIC8gMjtcbiAgICAgIGlmIChsYXRpdHVkZSA+IG1pZCkge1xuICAgICAgICBjb21iaW5lZEJpdHMgKz0gMTtcbiAgICAgICAgbWluTGF0ID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4TGF0ID0gbWlkO1xuICAgICAgfVxuICAgIH1cbiAgICBiaXRzVG90YWwrKztcbiAgfVxuICByZXR1cm4gY29tYmluZWRCaXRzO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgQm91bmRpbmcgQm94XG4gKlxuICogRGVjb2RlIGhhc2hTdHJpbmcgaW50byBhIGJvdW5kIGJveCBtYXRjaGVzIGl0LiBEYXRhIHJldHVybmVkIGluIGEgZm91ci1lbGVtZW50IGFycmF5OiBbbWlubGF0LCBtaW5sb24sIG1heGxhdCwgbWF4bG9uXVxuICogQHBhcmFtIHtTdHJpbmd9IGhhc2hfc3RyaW5nXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbnZhciBkZWNvZGVfYmJveCA9IGZ1bmN0aW9uIChoYXNoX3N0cmluZykge1xuICB2YXIgaXNMb24gPSB0cnVlLFxuICAgIG1heExhdCA9IE1BWF9MQVQsXG4gICAgbWluTGF0ID0gTUlOX0xBVCxcbiAgICBtYXhMb24gPSBNQVhfTE9OLFxuICAgIG1pbkxvbiA9IE1JTl9MT04sXG4gICAgbWlkO1xuXG4gIHZhciBoYXNoVmFsdWUgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhc2hfc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjb2RlID0gaGFzaF9zdHJpbmdbaV0udG9Mb3dlckNhc2UoKTtcbiAgICBoYXNoVmFsdWUgPSBCQVNFMzJfQ09ERVNfRElDVFtjb2RlXTtcblxuICAgIGZvciAodmFyIGJpdHMgPSA0OyBiaXRzID49IDA7IGJpdHMtLSkge1xuICAgICAgdmFyIGJpdCA9IChoYXNoVmFsdWUgPj4gYml0cykgJiAxO1xuICAgICAgaWYgKGlzTG9uKSB7XG4gICAgICAgIG1pZCA9IChtYXhMb24gKyBtaW5Mb24pIC8gMjtcbiAgICAgICAgaWYgKGJpdCA9PT0gMSkge1xuICAgICAgICAgIG1pbkxvbiA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhMb24gPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pZCA9IChtYXhMYXQgKyBtaW5MYXQpIC8gMjtcbiAgICAgICAgaWYgKGJpdCA9PT0gMSkge1xuICAgICAgICAgIG1pbkxhdCA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhMYXQgPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzTG9uID0gIWlzTG9uO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW21pbkxhdCwgbWluTG9uLCBtYXhMYXQsIG1heExvbl07XG59O1xuXG4vKipcbiAqIERlY29kZSBCb3VuZGluZyBCb3ggSW50ZWdlclxuICpcbiAqIERlY29kZSBoYXNoIG51bWJlciBpbnRvIGEgYm91bmQgYm94IG1hdGNoZXMgaXQuIERhdGEgcmV0dXJuZWQgaW4gYSBmb3VyLWVsZW1lbnQgYXJyYXk6IFttaW5sYXQsIG1pbmxvbiwgbWF4bGF0LCBtYXhsb25dXG4gKiBAcGFyYW0ge051bWJlcn0gaGFzaEludFxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdERlcHRoXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbnZhciBkZWNvZGVfYmJveF9pbnQgPSBmdW5jdGlvbiAoaGFzaEludCwgYml0RGVwdGgpIHtcblxuICBiaXREZXB0aCA9IGJpdERlcHRoIHx8IDUyO1xuXG4gIHZhciBtYXhMYXQgPSBNQVhfTEFULFxuICBtaW5MYXQgPSBNSU5fTEFULFxuICBtYXhMb24gPSBNQVhfTE9OLFxuICBtaW5Mb24gPSBNSU5fTE9OO1xuXG4gIHZhciBsYXRCaXQgPSAwLCBsb25CaXQgPSAwO1xuICB2YXIgc3RlcCA9IGJpdERlcHRoIC8gMjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXA7IGkrKykge1xuXG4gICAgbG9uQml0ID0gZ2V0X2JpdChoYXNoSW50LCAoKHN0ZXAgLSBpKSAqIDIpIC0gMSk7XG4gICAgbGF0Qml0ID0gZ2V0X2JpdChoYXNoSW50LCAoKHN0ZXAgLSBpKSAqIDIpIC0gMik7XG5cbiAgICBpZiAobGF0Qml0ID09PSAwKSB7XG4gICAgICBtYXhMYXQgPSAobWF4TGF0ICsgbWluTGF0KSAvIDI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbWluTGF0ID0gKG1heExhdCArIG1pbkxhdCkgLyAyO1xuICAgIH1cblxuICAgIGlmIChsb25CaXQgPT09IDApIHtcbiAgICAgIG1heExvbiA9IChtYXhMb24gKyBtaW5Mb24pIC8gMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBtaW5Mb24gPSAobWF4TG9uICsgbWluTG9uKSAvIDI7XG4gICAgfVxuICB9XG4gIHJldHVybiBbbWluTGF0LCBtaW5Mb24sIG1heExhdCwgbWF4TG9uXTtcbn07XG5cbmZ1bmN0aW9uIGdldF9iaXQoYml0cywgcG9zaXRpb24pIHtcbiAgcmV0dXJuIChiaXRzIC8gTWF0aC5wb3coMiwgcG9zaXRpb24pKSAmIDB4MDE7XG59XG5cbi8qKlxuICogRGVjb2RlXG4gKlxuICogRGVjb2RlIGEgaGFzaCBzdHJpbmcgaW50byBwYWlyIG9mIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuIEEgamF2YXNjcmlwdCBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCBrZXlzIGBsYXRpdHVkZWAsXG4gKiBgbG9uZ2l0dWRlYCBhbmQgYGVycm9yYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoU3RyaW5nXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gKGhhc2hTdHJpbmcpIHtcbiAgdmFyIGJib3ggPSBkZWNvZGVfYmJveChoYXNoU3RyaW5nKTtcbiAgdmFyIGxhdCA9IChiYm94WzBdICsgYmJveFsyXSkgLyAyO1xuICB2YXIgbG9uID0gKGJib3hbMV0gKyBiYm94WzNdKSAvIDI7XG4gIHZhciBsYXRFcnIgPSBiYm94WzJdIC0gbGF0O1xuICB2YXIgbG9uRXJyID0gYmJveFszXSAtIGxvbjtcbiAgcmV0dXJuIHtsYXRpdHVkZTogbGF0LCBsb25naXR1ZGU6IGxvbixcbiAgICAgIGVycm9yOiB7bGF0aXR1ZGU6IGxhdEVyciwgbG9uZ2l0dWRlOiBsb25FcnJ9fTtcbn07XG5cbi8qKlxuICogRGVjb2RlIEludGVnZXJcbiAqXG4gKiBEZWNvZGUgYSBoYXNoIG51bWJlciBpbnRvIHBhaXIgb2YgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS4gQSBqYXZhc2NyaXB0IG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIGtleXMgYGxhdGl0dWRlYCxcbiAqIGBsb25naXR1ZGVgIGFuZCBgZXJyb3JgLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhhc2hfaW50XG4gKiBAcGFyYW0ge051bWJlcn0gYml0RGVwdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbnZhciBkZWNvZGVfaW50ID0gZnVuY3Rpb24gKGhhc2hfaW50LCBiaXREZXB0aCkge1xuICB2YXIgYmJveCA9IGRlY29kZV9iYm94X2ludChoYXNoX2ludCwgYml0RGVwdGgpO1xuICB2YXIgbGF0ID0gKGJib3hbMF0gKyBiYm94WzJdKSAvIDI7XG4gIHZhciBsb24gPSAoYmJveFsxXSArIGJib3hbM10pIC8gMjtcbiAgdmFyIGxhdEVyciA9IGJib3hbMl0gLSBsYXQ7XG4gIHZhciBsb25FcnIgPSBiYm94WzNdIC0gbG9uO1xuICByZXR1cm4ge2xhdGl0dWRlOiBsYXQsIGxvbmdpdHVkZTogbG9uLFxuICAgICAgICAgIGVycm9yOiB7bGF0aXR1ZGU6IGxhdEVyciwgbG9uZ2l0dWRlOiBsb25FcnJ9fTtcbn07XG5cbi8qKlxuICogTmVpZ2hib3JcbiAqXG4gKiBGaW5kIG5laWdoYm9yIG9mIGEgZ2VvaGFzaCBzdHJpbmcgaW4gY2VydGFpbiBkaXJlY3Rpb24uIERpcmVjdGlvbiBpcyBhIHR3by1lbGVtZW50IGFycmF5LCBpLmUuIFsxLDBdIG1lYW5zIG5vcnRoLCBbLTEsLTFdIG1lYW5zIHNvdXRod2VzdC5cbiAqIGRpcmVjdGlvbiBbbGF0LCBsb25dLCBpLmUuXG4gKiBbMSwwXSAtIG5vcnRoXG4gKiBbMSwxXSAtIG5vcnRoZWFzdFxuICogLi4uXG4gKiBAcGFyYW0ge1N0cmluZ30gaGFzaFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gRGlyZWN0aW9uIGFzIGEgMkQgbm9ybWFsaXplZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG52YXIgbmVpZ2hib3IgPSBmdW5jdGlvbiAoaGFzaFN0cmluZywgZGlyZWN0aW9uKSB7XG4gIHZhciBsb25MYXQgPSBkZWNvZGUoaGFzaFN0cmluZyk7XG4gIHZhciBuZWlnaGJvckxhdCA9IGxvbkxhdC5sYXRpdHVkZVxuICAgICsgZGlyZWN0aW9uWzBdICogbG9uTGF0LmVycm9yLmxhdGl0dWRlICogMjtcbiAgdmFyIG5laWdoYm9yTG9uID0gbG9uTGF0LmxvbmdpdHVkZVxuICAgICsgZGlyZWN0aW9uWzFdICogbG9uTGF0LmVycm9yLmxvbmdpdHVkZSAqIDI7XG4gIG5laWdoYm9yTG9uID0gZW5zdXJlX3ZhbGlkX2xvbihuZWlnaGJvckxvbik7XG4gIG5laWdoYm9yTGF0ID0gZW5zdXJlX3ZhbGlkX2xhdChuZWlnaGJvckxhdCk7XG4gIHJldHVybiBlbmNvZGUobmVpZ2hib3JMYXQsIG5laWdoYm9yTG9uLCBoYXNoU3RyaW5nLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIE5laWdoYm9yIEludGVnZXJcbiAqXG4gKiBGaW5kIG5laWdoYm9yIG9mIGEgZ2VvaGFzaCBpbnRlZ2VyIGluIGNlcnRhaW4gZGlyZWN0aW9uLiBEaXJlY3Rpb24gaXMgYSB0d28tZWxlbWVudCBhcnJheSwgaS5lLiBbMSwwXSBtZWFucyBub3J0aCwgWy0xLC0xXSBtZWFucyBzb3V0aHdlc3QuXG4gKiBkaXJlY3Rpb24gW2xhdCwgbG9uXSwgaS5lLlxuICogWzEsMF0gLSBub3J0aFxuICogWzEsMV0gLSBub3J0aGVhc3RcbiAqIC4uLlxuICogQHBhcmFtIHtTdHJpbmd9IGhhc2hfc3RyaW5nXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4qL1xudmFyIG5laWdoYm9yX2ludCA9IGZ1bmN0aW9uIChoYXNoX2ludCwgZGlyZWN0aW9uLCBiaXREZXB0aCkge1xuICAgIGJpdERlcHRoID0gYml0RGVwdGggfHwgNTI7XG4gICAgdmFyIGxvbmxhdCA9IGRlY29kZV9pbnQoaGFzaF9pbnQsIGJpdERlcHRoKTtcbiAgICB2YXIgbmVpZ2hib3JfbGF0ID0gbG9ubGF0LmxhdGl0dWRlICsgZGlyZWN0aW9uWzBdICogbG9ubGF0LmVycm9yLmxhdGl0dWRlICogMjtcbiAgICB2YXIgbmVpZ2hib3JfbG9uID0gbG9ubGF0LmxvbmdpdHVkZSArIGRpcmVjdGlvblsxXSAqIGxvbmxhdC5lcnJvci5sb25naXR1ZGUgKiAyO1xuICAgIG5laWdoYm9yX2xvbiA9IGVuc3VyZV92YWxpZF9sb24obmVpZ2hib3JfbG9uKTtcbiAgICBuZWlnaGJvcl9sYXQgPSBlbnN1cmVfdmFsaWRfbGF0KG5laWdoYm9yX2xhdCk7XG4gICAgcmV0dXJuIGVuY29kZV9pbnQobmVpZ2hib3JfbGF0LCBuZWlnaGJvcl9sb24sIGJpdERlcHRoKTtcbn07XG5cbi8qKlxuICogTmVpZ2hib3JzXG4gKlxuICogUmV0dXJucyBhbGwgbmVpZ2hib3JzJyBoYXNoc3RyaW5ncyBjbG9ja3dpc2UgZnJvbSBub3J0aCBhcm91bmQgdG8gbm9ydGh3ZXN0XG4gKiA3IDAgMVxuICogNiB4IDJcbiAqIDUgNCAzXG4gKiBAcGFyYW0ge1N0cmluZ30gaGFzaF9zdHJpbmdcbiAqIEByZXR1cm5zIHtlbmNvZGVkIG5laWdoYm9ySGFzaExpc3R8QXJyYXl9XG4gKi9cbnZhciBuZWlnaGJvcnMgPSBmdW5jdGlvbiAoaGFzaF9zdHJpbmcpIHtcblxuICAgIHZhciBoYXNoc3RyaW5nTGVuZ3RoID0gaGFzaF9zdHJpbmcubGVuZ3RoO1xuXG4gICAgdmFyIGxvbmxhdCA9IGRlY29kZShoYXNoX3N0cmluZyk7XG4gICAgdmFyIGxhdCA9IGxvbmxhdC5sYXRpdHVkZTtcbiAgICB2YXIgbG9uID0gbG9ubGF0LmxvbmdpdHVkZTtcbiAgICB2YXIgbGF0RXJyID0gbG9ubGF0LmVycm9yLmxhdGl0dWRlICogMjtcbiAgICB2YXIgbG9uRXJyID0gbG9ubGF0LmVycm9yLmxvbmdpdHVkZSAqIDI7XG5cbiAgICB2YXIgbmVpZ2hib3JfbGF0LFxuICAgICAgICBuZWlnaGJvcl9sb247XG5cbiAgICB2YXIgbmVpZ2hib3JIYXNoTGlzdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVOZWlnaGJvcigxLDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZU5laWdoYm9yKDEsMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3IoMCwxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVOZWlnaGJvcigtMSwxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVOZWlnaGJvcigtMSwwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVOZWlnaGJvcigtMSwtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3IoMCwtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3IoMSwtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgZnVuY3Rpb24gZW5jb2RlTmVpZ2hib3IobmVpZ2hib3JMYXREaXIsIG5laWdoYm9yTG9uRGlyKXtcbiAgICAgICAgbmVpZ2hib3JfbGF0ID0gbGF0ICsgbmVpZ2hib3JMYXREaXIgKiBsYXRFcnI7XG4gICAgICAgIG5laWdoYm9yX2xvbiA9IGxvbiArIG5laWdoYm9yTG9uRGlyICogbG9uRXJyO1xuICAgICAgICBuZWlnaGJvcl9sb24gPSBlbnN1cmVfdmFsaWRfbG9uKG5laWdoYm9yX2xvbik7XG4gICAgICAgIG5laWdoYm9yX2xhdCA9IGVuc3VyZV92YWxpZF9sYXQobmVpZ2hib3JfbGF0KTtcbiAgICAgICAgcmV0dXJuIGVuY29kZShuZWlnaGJvcl9sYXQsIG5laWdoYm9yX2xvbiwgaGFzaHN0cmluZ0xlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5laWdoYm9ySGFzaExpc3Q7XG59O1xuXG4vKipcbiAqIE5laWdoYm9ycyBJbnRlZ2VyXG4gKlxuICogUmV0dXJucyBhbGwgbmVpZ2hib3JzJyBoYXNoIGludGVnZXJzIGNsb2Nrd2lzZSBmcm9tIG5vcnRoIGFyb3VuZCB0byBub3J0aHdlc3RcbiAqIDcgMCAxXG4gKiA2IHggMlxuICogNSA0IDNcbiAqIEBwYXJhbSB7TnVtYmVyfSBoYXNoX2ludFxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdERlcHRoXG4gKiBAcmV0dXJucyB7ZW5jb2RlX2ludCdkIG5laWdoYm9ySGFzaEludExpc3R8QXJyYXl9XG4gKi9cbnZhciBuZWlnaGJvcnNfaW50ID0gZnVuY3Rpb24oaGFzaF9pbnQsIGJpdERlcHRoKXtcblxuICAgIGJpdERlcHRoID0gYml0RGVwdGggfHwgNTI7XG5cbiAgICB2YXIgbG9ubGF0ID0gZGVjb2RlX2ludChoYXNoX2ludCwgYml0RGVwdGgpO1xuICAgIHZhciBsYXQgPSBsb25sYXQubGF0aXR1ZGU7XG4gICAgdmFyIGxvbiA9IGxvbmxhdC5sb25naXR1ZGU7XG4gICAgdmFyIGxhdEVyciA9IGxvbmxhdC5lcnJvci5sYXRpdHVkZSAqIDI7XG4gICAgdmFyIGxvbkVyciA9IGxvbmxhdC5lcnJvci5sb25naXR1ZGUgKiAyO1xuXG4gICAgdmFyIG5laWdoYm9yX2xhdCxcbiAgICAgICAgbmVpZ2hib3JfbG9uO1xuXG4gICAgdmFyIG5laWdoYm9ySGFzaEludExpc3QgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3JfaW50KDEsMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3JfaW50KDEsMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3JfaW50KDAsMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3JfaW50KC0xLDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZU5laWdoYm9yX2ludCgtMSwwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVOZWlnaGJvcl9pbnQoLTEsLTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZU5laWdoYm9yX2ludCgwLC0xKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVOZWlnaGJvcl9pbnQoMSwtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgZnVuY3Rpb24gZW5jb2RlTmVpZ2hib3JfaW50KG5laWdoYm9yTGF0RGlyLCBuZWlnaGJvckxvbkRpcil7XG4gICAgICAgIG5laWdoYm9yX2xhdCA9IGxhdCArIG5laWdoYm9yTGF0RGlyICogbGF0RXJyO1xuICAgICAgICBuZWlnaGJvcl9sb24gPSBsb24gKyBuZWlnaGJvckxvbkRpciAqIGxvbkVycjtcbiAgICAgICAgbmVpZ2hib3JfbG9uID0gZW5zdXJlX3ZhbGlkX2xvbihuZWlnaGJvcl9sb24pO1xuICAgICAgICBuZWlnaGJvcl9sYXQgPSBlbnN1cmVfdmFsaWRfbGF0KG5laWdoYm9yX2xhdCk7XG4gICAgICAgIHJldHVybiBlbmNvZGVfaW50KG5laWdoYm9yX2xhdCwgbmVpZ2hib3JfbG9uLCBiaXREZXB0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5laWdoYm9ySGFzaEludExpc3Q7XG59O1xuXG5cbi8qKlxuICogQm91bmRpbmcgQm94ZXNcbiAqXG4gKiBSZXR1cm4gYWxsIHRoZSBoYXNoU3RyaW5nIGJldHdlZW4gbWluTGF0LCBtaW5Mb24sIG1heExhdCwgbWF4TG9uIGluIG51bWJlck9mQ2hhcnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5MYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5Mb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJPZkNoYXJzXG4gKiBAcmV0dXJucyB7YmJveGVzLmhhc2hMaXN0fEFycmF5fVxuICovXG52YXIgYmJveGVzID0gZnVuY3Rpb24gKG1pbkxhdCwgbWluTG9uLCBtYXhMYXQsIG1heExvbiwgbnVtYmVyT2ZDaGFycykge1xuICBudW1iZXJPZkNoYXJzID0gbnVtYmVyT2ZDaGFycyB8fCA5O1xuXG4gIHZhciBoYXNoU291dGhXZXN0ID0gZW5jb2RlKG1pbkxhdCwgbWluTG9uLCBudW1iZXJPZkNoYXJzKTtcbiAgdmFyIGhhc2hOb3J0aEVhc3QgPSBlbmNvZGUobWF4TGF0LCBtYXhMb24sIG51bWJlck9mQ2hhcnMpO1xuXG4gIHZhciBsYXRMb24gPSBkZWNvZGUoaGFzaFNvdXRoV2VzdCk7XG5cbiAgdmFyIHBlckxhdCA9IGxhdExvbi5lcnJvci5sYXRpdHVkZSAqIDI7XG4gIHZhciBwZXJMb24gPSBsYXRMb24uZXJyb3IubG9uZ2l0dWRlICogMjtcblxuICB2YXIgYm94U291dGhXZXN0ID0gZGVjb2RlX2Jib3goaGFzaFNvdXRoV2VzdCk7XG4gIHZhciBib3hOb3J0aEVhc3QgPSBkZWNvZGVfYmJveChoYXNoTm9ydGhFYXN0KTtcblxuICB2YXIgbGF0U3RlcCA9IE1hdGgucm91bmQoKGJveE5vcnRoRWFzdFswXSAtIGJveFNvdXRoV2VzdFswXSkgLyBwZXJMYXQpO1xuICB2YXIgbG9uU3RlcCA9IE1hdGgucm91bmQoKGJveE5vcnRoRWFzdFsxXSAtIGJveFNvdXRoV2VzdFsxXSkgLyBwZXJMb24pO1xuXG4gIHZhciBoYXNoTGlzdCA9IFtdO1xuXG4gIGZvciAodmFyIGxhdCA9IDA7IGxhdCA8PSBsYXRTdGVwOyBsYXQrKykge1xuICAgIGZvciAodmFyIGxvbiA9IDA7IGxvbiA8PSBsb25TdGVwOyBsb24rKykge1xuICAgICAgaGFzaExpc3QucHVzaChuZWlnaGJvcihoYXNoU291dGhXZXN0LCBbbGF0LCBsb25dKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc2hMaXN0O1xufTtcblxuLyoqXG4gKiBCb3VuZGluZyBCb3hlcyBJbnRlZ2VyXG4gKlxuICogUmV0dXJuIGFsbCB0aGUgaGFzaCBpbnRlZ2VycyBiZXR3ZWVuIG1pbkxhdCwgbWluTG9uLCBtYXhMYXQsIG1heExvbiBpbiBiaXREZXB0aFxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbkxhdFxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbkxvblxuICogQHBhcmFtIHtOdW1iZXJ9IG1heExhdFxuICogQHBhcmFtIHtOdW1iZXJ9IG1heExvblxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdERlcHRoXG4gKiBAcmV0dXJucyB7YmJveGVzX2ludC5oYXNoTGlzdHxBcnJheX1cbiAqL1xudmFyIGJib3hlc19pbnQgPSBmdW5jdGlvbihtaW5MYXQsIG1pbkxvbiwgbWF4TGF0LCBtYXhMb24sIGJpdERlcHRoKXtcbiAgICBiaXREZXB0aCA9IGJpdERlcHRoIHx8IDUyO1xuXG4gICAgdmFyIGhhc2hTb3V0aFdlc3QgPSBlbmNvZGVfaW50KG1pbkxhdCwgbWluTG9uLCBiaXREZXB0aCk7XG4gICAgdmFyIGhhc2hOb3J0aEVhc3QgPSBlbmNvZGVfaW50KG1heExhdCwgbWF4TG9uLCBiaXREZXB0aCk7XG5cbiAgICB2YXIgbGF0bG9uID0gZGVjb2RlX2ludChoYXNoU291dGhXZXN0LCBiaXREZXB0aCk7XG5cbiAgICB2YXIgcGVyTGF0ID0gbGF0bG9uLmVycm9yLmxhdGl0dWRlICogMjtcbiAgICB2YXIgcGVyTG9uID0gbGF0bG9uLmVycm9yLmxvbmdpdHVkZSAqIDI7XG5cbiAgICB2YXIgYm94U291dGhXZXN0ID0gZGVjb2RlX2Jib3hfaW50KGhhc2hTb3V0aFdlc3QsIGJpdERlcHRoKTtcbiAgICB2YXIgYm94Tm9ydGhFYXN0ID0gZGVjb2RlX2Jib3hfaW50KGhhc2hOb3J0aEVhc3QsIGJpdERlcHRoKTtcblxuICAgIHZhciBsYXRTdGVwID0gTWF0aC5yb3VuZCgoYm94Tm9ydGhFYXN0WzBdIC0gYm94U291dGhXZXN0WzBdKS9wZXJMYXQpO1xuICAgIHZhciBsb25TdGVwID0gTWF0aC5yb3VuZCgoYm94Tm9ydGhFYXN0WzFdIC0gYm94U291dGhXZXN0WzFdKS9wZXJMb24pO1xuXG4gICAgdmFyIGhhc2hMaXN0ID0gW107XG5cbiAgICBmb3IodmFyIGxhdCA9IDA7IGxhdCA8PSBsYXRTdGVwOyBsYXQrKyl7XG4gICAgICAgIGZvcih2YXIgbG9uID0gMDsgbG9uIDw9IGxvblN0ZXA7IGxvbisrKXtcbiAgICAgICAgICAgIGhhc2hMaXN0LnB1c2gobmVpZ2hib3JfaW50KGhhc2hTb3V0aFdlc3QsW2xhdCwgbG9uXSwgYml0RGVwdGgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICByZXR1cm4gaGFzaExpc3Q7XG59O1xuXG5mdW5jdGlvbiBlbnN1cmVfdmFsaWRfbG9uKGxvbikge1xuICBpZiAobG9uID4gTUFYX0xPTilcbiAgICByZXR1cm4gTUlOX0xPTiArIGxvbiAlIE1BWF9MT047XG4gIGlmIChsb24gPCBNSU5fTE9OKVxuICAgIHJldHVybiBNQVhfTE9OICsgbG9uICUgTUFYX0xPTjtcbiAgcmV0dXJuIGxvbjtcbn07XG5cbmZ1bmN0aW9uIGVuc3VyZV92YWxpZF9sYXQobGF0KSB7XG4gIGlmIChsYXQgPiBNQVhfTEFUKVxuICAgIHJldHVybiBNQVhfTEFUO1xuICBpZiAobGF0IDwgTUlOX0xBVClcbiAgICByZXR1cm4gTUlOX0xBVDtcbiAgcmV0dXJuIGxhdDtcbn07XG5cbnZhciBnZW9oYXNoID0ge1xuICAnRU5DT0RFX0FVVE8nOiBFTkNPREVfQVVUTyxcbiAgJ2VuY29kZSc6IGVuY29kZSxcbiAgJ2VuY29kZV91aW50NjQnOiBlbmNvZGVfaW50LCAvLyBrZWVwaW5nIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2lsbCBkZXByZWNhdGVcbiAgJ2VuY29kZV9pbnQnOiBlbmNvZGVfaW50LFxuICAnZGVjb2RlJzogZGVjb2RlLFxuICAnZGVjb2RlX2ludCc6IGRlY29kZV9pbnQsXG4gICdkZWNvZGVfdWludDY0JzogZGVjb2RlX2ludCwgLy8ga2VlcGluZyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdpbGwgZGVwcmVjYXRlXG4gICdkZWNvZGVfYmJveCc6IGRlY29kZV9iYm94LFxuICAnZGVjb2RlX2Jib3hfdWludDY0JzogZGVjb2RlX2Jib3hfaW50LCAvLyBrZWVwaW5nIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2lsbCBkZXByZWNhdGVcbiAgJ2RlY29kZV9iYm94X2ludCc6IGRlY29kZV9iYm94X2ludCxcbiAgJ25laWdoYm9yJzogbmVpZ2hib3IsXG4gICduZWlnaGJvcl9pbnQnOiBuZWlnaGJvcl9pbnQsXG4gICduZWlnaGJvcnMnOiBuZWlnaGJvcnMsXG4gICduZWlnaGJvcnNfaW50JzogbmVpZ2hib3JzX2ludCxcbiAgJ2Jib3hlcyc6IGJib3hlcyxcbiAgJ2Jib3hlc19pbnQnOiBiYm94ZXNfaW50XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlb2hhc2g7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/ngeohash@0.6.3/node_modules/ngeohash/main.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/v2/useCourierLocationWriter.ts":
/*!**************************************************!*\
  !*** ./src/hooks/v2/useCourierLocationWriter.ts ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCourierLocationWriter: () => (/* binding */ useCourierLocationWriter)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.5.9_react-dom@19.2.3_react@19.2.3/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/../../node_modules/.pnpm/firebase@11.10.0/node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_firebase_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/firebase/client */ \"(app-pages-browser)/./src/lib/firebase/client.ts\");\n/* harmony import */ var _useUserRole__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useUserRole */ \"(app-pages-browser)/./src/hooks/v2/useUserRole.ts\");\n/* harmony import */ var ngeohash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ngeohash */ \"(app-pages-browser)/../../node_modules/.pnpm/ngeohash@0.6.3/node_modules/ngeohash/main.js\");\n/* harmony import */ var ngeohash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ngeohash__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ useCourierLocationWriter auto */ \n\n\n\n\nconst WRITE_INTERVAL_MS = 5000; // Write at most every 5 seconds\nconst MOVE_THRESHOLD_METERS = 25; // Or if moved > 25 meters\nfunction getDistance(lat1, lon1, lat2, lon2) {\n    const R = 6371e3; // Earth radius in meters\n    const φ1 = lat1 * Math.PI / 180;\n    const φ2 = lat2 * Math.PI / 180;\n    const Δφ = (lat2 - lat1) * Math.PI / 180;\n    const Δλ = (lon2 - lon1) * Math.PI / 180;\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n}\nfunction useCourierLocationWriter() {\n    var _userDoc_courier;\n    const { role, uid, userDoc } = (0,_useUserRole__WEBPACK_IMPORTED_MODULE_3__.useUserRole)();\n    const [permissionDenied, setPermissionDenied] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isTracking, setIsTracking] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const watchIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const lastWriteTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const lastPositionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCourierLocationWriter.useEffect\": ()=>{\n            var _userDoc_courier;\n            // Only track if courier and online\n            const shouldTrack = role === 'courier' && uid && (userDoc === null || userDoc === void 0 ? void 0 : (_userDoc_courier = userDoc.courier) === null || _userDoc_courier === void 0 ? void 0 : _userDoc_courier.isOnline) === true;\n            if (!shouldTrack) {\n                // Stop tracking\n                if (watchIdRef.current !== null) {\n                    navigator.geolocation.clearWatch(watchIdRef.current);\n                    watchIdRef.current = null;\n                    setIsTracking(false);\n                }\n                return;\n            }\n            // Start tracking\n            if (watchIdRef.current === null) {\n                setIsTracking(true);\n                setPermissionDenied(false);\n                watchIdRef.current = navigator.geolocation.watchPosition({\n                    \"useCourierLocationWriter.useEffect\": async (position)=>{\n                        const { latitude: lat, longitude: lng, heading } = position.coords;\n                        const now = Date.now();\n                        // Throttle: check time and distance\n                        const timeSinceLastWrite = now - lastWriteTimeRef.current;\n                        let shouldWrite = timeSinceLastWrite >= WRITE_INTERVAL_MS;\n                        if (!shouldWrite && lastPositionRef.current) {\n                            const distance = getDistance(lastPositionRef.current.lat, lastPositionRef.current.lng, lat, lng);\n                            shouldWrite = distance >= MOVE_THRESHOLD_METERS;\n                        }\n                        if (shouldWrite && uid) {\n                            try {\n                                const geoHash = ngeohash__WEBPACK_IMPORTED_MODULE_4___default().encode(lat, lng, 6);\n                                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase_client__WEBPACK_IMPORTED_MODULE_2__.db, 'users', uid), {\n                                    'location.lat': lat,\n                                    'location.lng': lng,\n                                    'location.geohash': geoHash,\n                                    ...heading !== null && {\n                                        'location.heading': heading\n                                    },\n                                    'location.updatedAt': (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                                });\n                                lastWriteTimeRef.current = now;\n                                lastPositionRef.current = {\n                                    lat,\n                                    lng\n                                };\n                            } catch (error) {\n                                console.error('Failed to update courier location:', error);\n                            }\n                        }\n                    }\n                }[\"useCourierLocationWriter.useEffect\"], {\n                    \"useCourierLocationWriter.useEffect\": (error)=>{\n                        console.error('Geolocation error:', error);\n                        if (error.code === error.PERMISSION_DENIED) {\n                            setPermissionDenied(true);\n                        }\n                    }\n                }[\"useCourierLocationWriter.useEffect\"], {\n                    enableHighAccuracy: true,\n                    maximumAge: 0,\n                    timeout: 10000\n                });\n            }\n            return ({\n                \"useCourierLocationWriter.useEffect\": ()=>{\n                    if (watchIdRef.current !== null) {\n                        navigator.geolocation.clearWatch(watchIdRef.current);\n                        watchIdRef.current = null;\n                        setIsTracking(false);\n                    }\n                }\n            })[\"useCourierLocationWriter.useEffect\"];\n        }\n    }[\"useCourierLocationWriter.useEffect\"], [\n        role,\n        uid,\n        userDoc === null || userDoc === void 0 ? void 0 : (_userDoc_courier = userDoc.courier) === null || _userDoc_courier === void 0 ? void 0 : _userDoc_courier.isOnline\n    ]);\n    return {\n        isTracking,\n        permissionDenied\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy92Mi91c2VDb3VyaWVyTG9jYXRpb25Xcml0ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OEVBRW9EO0FBQ2lCO0FBQzFCO0FBQ0M7QUFDYjtBQUUvQixNQUFNUyxvQkFBb0IsTUFBTSxnQ0FBZ0M7QUFDaEUsTUFBTUMsd0JBQXdCLElBQUksMEJBQTBCO0FBRTVELFNBQVNDLFlBQVlDLElBQVksRUFBRUMsSUFBWSxFQUFFQyxJQUFZLEVBQUVDLElBQVk7SUFDekUsTUFBTUMsSUFBSSxRQUFRLHlCQUF5QjtJQUMzQyxNQUFNQyxLQUFLLE9BQVFDLEtBQUtDLEVBQUUsR0FBSTtJQUM5QixNQUFNQyxLQUFLLE9BQVFGLEtBQUtDLEVBQUUsR0FBSTtJQUM5QixNQUFNRSxLQUFLLENBQUVQLE9BQU9GLElBQUcsSUFBS00sS0FBS0MsRUFBRSxHQUFJO0lBQ3ZDLE1BQU1HLEtBQUssQ0FBRVAsT0FBT0YsSUFBRyxJQUFLSyxLQUFLQyxFQUFFLEdBQUk7SUFFdkMsTUFBTUksSUFDSkwsS0FBS00sR0FBRyxDQUFDSCxLQUFLLEtBQUtILEtBQUtNLEdBQUcsQ0FBQ0gsS0FBSyxLQUNqQ0gsS0FBS08sR0FBRyxDQUFDUixNQUFNQyxLQUFLTyxHQUFHLENBQUNMLE1BQU1GLEtBQUtNLEdBQUcsQ0FBQ0YsS0FBSyxLQUFLSixLQUFLTSxHQUFHLENBQUNGLEtBQUs7SUFDakUsTUFBTUksSUFBSSxJQUFJUixLQUFLUyxLQUFLLENBQUNULEtBQUtVLElBQUksQ0FBQ0wsSUFBSUwsS0FBS1UsSUFBSSxDQUFDLElBQUlMO0lBRXJELE9BQU9QLElBQUlVO0FBQ2I7QUFFTyxTQUFTRztRQTBGQ0M7SUF6RmYsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEdBQUcsRUFBRUYsT0FBTyxFQUFFLEdBQUd2Qix5REFBV0E7SUFDMUMsTUFBTSxDQUFDMEIsa0JBQWtCQyxvQkFBb0IsR0FBR2hDLCtDQUFRQSxDQUFDO0lBQ3pELE1BQU0sQ0FBQ2lDLFlBQVlDLGNBQWMsR0FBR2xDLCtDQUFRQSxDQUFDO0lBRTdDLE1BQU1tQyxhQUFhcEMsNkNBQU1BLENBQWdCO0lBQ3pDLE1BQU1xQyxtQkFBbUJyQyw2Q0FBTUEsQ0FBUztJQUN4QyxNQUFNc0Msa0JBQWtCdEMsNkNBQU1BLENBQXNDO0lBRXBFRCxnREFBU0E7OENBQUM7Z0JBS044QjtZQUpGLG1DQUFtQztZQUNuQyxNQUFNVSxjQUNKVCxTQUFTLGFBQ1RDLE9BQ0FGLENBQUFBLG9CQUFBQSwrQkFBQUEsbUJBQUFBLFFBQVNXLE9BQU8sY0FBaEJYLHVDQUFBQSxpQkFBa0JZLFFBQVEsTUFBSztZQUVqQyxJQUFJLENBQUNGLGFBQWE7Z0JBQ2hCLGdCQUFnQjtnQkFDaEIsSUFBSUgsV0FBV00sT0FBTyxLQUFLLE1BQU07b0JBQy9CQyxVQUFVQyxXQUFXLENBQUNDLFVBQVUsQ0FBQ1QsV0FBV00sT0FBTztvQkFDbkROLFdBQVdNLE9BQU8sR0FBRztvQkFDckJQLGNBQWM7Z0JBQ2hCO2dCQUNBO1lBQ0Y7WUFFQSxpQkFBaUI7WUFDakIsSUFBSUMsV0FBV00sT0FBTyxLQUFLLE1BQU07Z0JBQy9CUCxjQUFjO2dCQUNkRixvQkFBb0I7Z0JBRXBCRyxXQUFXTSxPQUFPLEdBQUdDLFVBQVVDLFdBQVcsQ0FBQ0UsYUFBYTswREFDdEQsT0FBT0M7d0JBQ0wsTUFBTSxFQUFFQyxVQUFVQyxHQUFHLEVBQUVDLFdBQVdDLEdBQUcsRUFBRUMsT0FBTyxFQUFFLEdBQUdMLFNBQVNNLE1BQU07d0JBQ2xFLE1BQU1DLE1BQU1DLEtBQUtELEdBQUc7d0JBRXBCLG9DQUFvQzt3QkFDcEMsTUFBTUUscUJBQXFCRixNQUFNakIsaUJBQWlCSyxPQUFPO3dCQUN6RCxJQUFJZSxjQUFjRCxzQkFBc0JoRDt3QkFFeEMsSUFBSSxDQUFDaUQsZUFBZW5CLGdCQUFnQkksT0FBTyxFQUFFOzRCQUMzQyxNQUFNZ0IsV0FBV2hELFlBQ2Y0QixnQkFBZ0JJLE9BQU8sQ0FBQ08sR0FBRyxFQUMzQlgsZ0JBQWdCSSxPQUFPLENBQUNTLEdBQUcsRUFDM0JGLEtBQ0FFOzRCQUVGTSxjQUFjQyxZQUFZakQ7d0JBQzVCO3dCQUVBLElBQUlnRCxlQUFlMUIsS0FBSzs0QkFDdEIsSUFBSTtnQ0FDRixNQUFNNEIsVUFBVXBELHNEQUFjLENBQUMwQyxLQUFLRSxLQUFLO2dDQUV6QyxNQUFNaEQsNkRBQVNBLENBQUNELHVEQUFHQSxDQUFDRyxvREFBRUEsRUFBRSxTQUFTMEIsTUFBTTtvQ0FDckMsZ0JBQWdCa0I7b0NBQ2hCLGdCQUFnQkU7b0NBQ2hCLG9CQUFvQlE7b0NBQ3BCLEdBQUlQLFlBQVksUUFBUTt3Q0FBRSxvQkFBb0JBO29DQUFRLENBQUM7b0NBQ3ZELHNCQUFzQmhELG1FQUFlQTtnQ0FDdkM7Z0NBRUFpQyxpQkFBaUJLLE9BQU8sR0FBR1k7Z0NBQzNCaEIsZ0JBQWdCSSxPQUFPLEdBQUc7b0NBQUVPO29DQUFLRTtnQ0FBSTs0QkFDdkMsRUFBRSxPQUFPVSxPQUFPO2dDQUNkQyxRQUFRRCxLQUFLLENBQUMsc0NBQXNDQTs0QkFDdEQ7d0JBQ0Y7b0JBQ0Y7OzBEQUNBLENBQUNBO3dCQUNDQyxRQUFRRCxLQUFLLENBQUMsc0JBQXNCQTt3QkFDcEMsSUFBSUEsTUFBTUUsSUFBSSxLQUFLRixNQUFNRyxpQkFBaUIsRUFBRTs0QkFDMUMvQixvQkFBb0I7d0JBQ3RCO29CQUNGO3lEQUNBO29CQUNFZ0Msb0JBQW9CO29CQUNwQkMsWUFBWTtvQkFDWkMsU0FBUztnQkFDWDtZQUVKO1lBRUE7c0RBQU87b0JBQ0wsSUFBSS9CLFdBQVdNLE9BQU8sS0FBSyxNQUFNO3dCQUMvQkMsVUFBVUMsV0FBVyxDQUFDQyxVQUFVLENBQUNULFdBQVdNLE9BQU87d0JBQ25ETixXQUFXTSxPQUFPLEdBQUc7d0JBQ3JCUCxjQUFjO29CQUNoQjtnQkFDRjs7UUFDRjs2Q0FBRztRQUFDTDtRQUFNQztRQUFLRixvQkFBQUEsK0JBQUFBLG1CQUFBQSxRQUFTVyxPQUFPLGNBQWhCWCx1Q0FBQUEsaUJBQWtCWSxRQUFRO0tBQUM7SUFFMUMsT0FBTztRQUNMUDtRQUNBRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXBhZGV2L2Rldi9hcHBzL2dvc2VuZGVyci9hcHBzL3dlYi9zcmMvaG9va3MvdjIvdXNlQ291cmllckxvY2F0aW9uV3JpdGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZG9jLCB1cGRhdGVEb2MsIHNlcnZlclRpbWVzdGFtcCB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJ0AvbGliL2ZpcmViYXNlL2NsaWVudCc7XG5pbXBvcnQgeyB1c2VVc2VyUm9sZSB9IGZyb20gJy4vdXNlVXNlclJvbGUnO1xuaW1wb3J0IGdlb2hhc2ggZnJvbSAnbmdlb2hhc2gnO1xuXG5jb25zdCBXUklURV9JTlRFUlZBTF9NUyA9IDUwMDA7IC8vIFdyaXRlIGF0IG1vc3QgZXZlcnkgNSBzZWNvbmRzXG5jb25zdCBNT1ZFX1RIUkVTSE9MRF9NRVRFUlMgPSAyNTsgLy8gT3IgaWYgbW92ZWQgPiAyNSBtZXRlcnNcblxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UobGF0MTogbnVtYmVyLCBsb24xOiBudW1iZXIsIGxhdDI6IG51bWJlciwgbG9uMjogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgUiA9IDYzNzFlMzsgLy8gRWFydGggcmFkaXVzIGluIG1ldGVyc1xuICBjb25zdCDPhjEgPSAobGF0MSAqIE1hdGguUEkpIC8gMTgwO1xuICBjb25zdCDPhjIgPSAobGF0MiAqIE1hdGguUEkpIC8gMTgwO1xuICBjb25zdCDOlM+GID0gKChsYXQyIC0gbGF0MSkgKiBNYXRoLlBJKSAvIDE4MDtcbiAgY29uc3QgzpTOuyA9ICgobG9uMiAtIGxvbjEpICogTWF0aC5QSSkgLyAxODA7XG5cbiAgY29uc3QgYSA9XG4gICAgTWF0aC5zaW4ozpTPhiAvIDIpICogTWF0aC5zaW4ozpTPhiAvIDIpICtcbiAgICBNYXRoLmNvcyjPhjEpICogTWF0aC5jb3Moz4YyKSAqIE1hdGguc2luKM6UzrsgLyAyKSAqIE1hdGguc2luKM6UzrsgLyAyKTtcbiAgY29uc3QgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG5cbiAgcmV0dXJuIFIgKiBjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ291cmllckxvY2F0aW9uV3JpdGVyKCkge1xuICBjb25zdCB7IHJvbGUsIHVpZCwgdXNlckRvYyB9ID0gdXNlVXNlclJvbGUoKTtcbiAgY29uc3QgW3Blcm1pc3Npb25EZW5pZWQsIHNldFBlcm1pc3Npb25EZW5pZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNUcmFja2luZywgc2V0SXNUcmFja2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICBjb25zdCB3YXRjaElkUmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBsYXN0V3JpdGVUaW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XG4gIGNvbnN0IGxhc3RQb3NpdGlvblJlZiA9IHVzZVJlZjx7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBPbmx5IHRyYWNrIGlmIGNvdXJpZXIgYW5kIG9ubGluZVxuICAgIGNvbnN0IHNob3VsZFRyYWNrID1cbiAgICAgIHJvbGUgPT09ICdjb3VyaWVyJyAmJlxuICAgICAgdWlkICYmXG4gICAgICB1c2VyRG9jPy5jb3VyaWVyPy5pc09ubGluZSA9PT0gdHJ1ZTtcblxuICAgIGlmICghc2hvdWxkVHJhY2spIHtcbiAgICAgIC8vIFN0b3AgdHJhY2tpbmdcbiAgICAgIGlmICh3YXRjaElkUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2god2F0Y2hJZFJlZi5jdXJyZW50KTtcbiAgICAgICAgd2F0Y2hJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgc2V0SXNUcmFja2luZyhmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdHJhY2tpbmdcbiAgICBpZiAod2F0Y2hJZFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBzZXRJc1RyYWNraW5nKHRydWUpO1xuICAgICAgc2V0UGVybWlzc2lvbkRlbmllZChmYWxzZSk7XG5cbiAgICAgIHdhdGNoSWRSZWYuY3VycmVudCA9IG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKFxuICAgICAgICBhc3luYyAocG9zaXRpb24pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGxhdGl0dWRlOiBsYXQsIGxvbmdpdHVkZTogbG5nLCBoZWFkaW5nIH0gPSBwb3NpdGlvbi5jb29yZHM7XG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgIC8vIFRocm90dGxlOiBjaGVjayB0aW1lIGFuZCBkaXN0YW5jZVxuICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RXcml0ZSA9IG5vdyAtIGxhc3RXcml0ZVRpbWVSZWYuY3VycmVudDtcbiAgICAgICAgICBsZXQgc2hvdWxkV3JpdGUgPSB0aW1lU2luY2VMYXN0V3JpdGUgPj0gV1JJVEVfSU5URVJWQUxfTVM7XG5cbiAgICAgICAgICBpZiAoIXNob3VsZFdyaXRlICYmIGxhc3RQb3NpdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGdldERpc3RhbmNlKFxuICAgICAgICAgICAgICBsYXN0UG9zaXRpb25SZWYuY3VycmVudC5sYXQsXG4gICAgICAgICAgICAgIGxhc3RQb3NpdGlvblJlZi5jdXJyZW50LmxuZyxcbiAgICAgICAgICAgICAgbGF0LFxuICAgICAgICAgICAgICBsbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzaG91bGRXcml0ZSA9IGRpc3RhbmNlID49IE1PVkVfVEhSRVNIT0xEX01FVEVSUztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkV3JpdGUgJiYgdWlkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBnZW9IYXNoID0gZ2VvaGFzaC5lbmNvZGUobGF0LCBsbmcsIDYpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGRvYyhkYiwgJ3VzZXJzJywgdWlkKSwge1xuICAgICAgICAgICAgICAgICdsb2NhdGlvbi5sYXQnOiBsYXQsXG4gICAgICAgICAgICAgICAgJ2xvY2F0aW9uLmxuZyc6IGxuZyxcbiAgICAgICAgICAgICAgICAnbG9jYXRpb24uZ2VvaGFzaCc6IGdlb0hhc2gsXG4gICAgICAgICAgICAgICAgLi4uKGhlYWRpbmcgIT09IG51bGwgJiYgeyAnbG9jYXRpb24uaGVhZGluZyc6IGhlYWRpbmcgfSksXG4gICAgICAgICAgICAgICAgJ2xvY2F0aW9uLnVwZGF0ZWRBdCc6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBsYXN0V3JpdGVUaW1lUmVmLmN1cnJlbnQgPSBub3c7XG4gICAgICAgICAgICAgIGxhc3RQb3NpdGlvblJlZi5jdXJyZW50ID0geyBsYXQsIGxuZyB9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBjb3VyaWVyIGxvY2F0aW9uOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dlb2xvY2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gZXJyb3IuUEVSTUlTU0lPTl9ERU5JRUQpIHtcbiAgICAgICAgICAgIHNldFBlcm1pc3Npb25EZW5pZWQodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlLFxuICAgICAgICAgIG1heGltdW1BZ2U6IDAsXG4gICAgICAgICAgdGltZW91dDogMTAwMDAsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh3YXRjaElkUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2god2F0Y2hJZFJlZi5jdXJyZW50KTtcbiAgICAgICAgd2F0Y2hJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgc2V0SXNUcmFja2luZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3JvbGUsIHVpZCwgdXNlckRvYz8uY291cmllcj8uaXNPbmxpbmVdKTtcblxuICByZXR1cm4ge1xuICAgIGlzVHJhY2tpbmcsXG4gICAgcGVybWlzc2lvbkRlbmllZCxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImRvYyIsInVwZGF0ZURvYyIsInNlcnZlclRpbWVzdGFtcCIsImRiIiwidXNlVXNlclJvbGUiLCJnZW9oYXNoIiwiV1JJVEVfSU5URVJWQUxfTVMiLCJNT1ZFX1RIUkVTSE9MRF9NRVRFUlMiLCJnZXREaXN0YW5jZSIsImxhdDEiLCJsb24xIiwibGF0MiIsImxvbjIiLCJSIiwiz4YxIiwiTWF0aCIsIlBJIiwiz4YyIiwizpTPhiIsIs6UzrsiLCJhIiwic2luIiwiY29zIiwiYyIsImF0YW4yIiwic3FydCIsInVzZUNvdXJpZXJMb2NhdGlvbldyaXRlciIsInVzZXJEb2MiLCJyb2xlIiwidWlkIiwicGVybWlzc2lvbkRlbmllZCIsInNldFBlcm1pc3Npb25EZW5pZWQiLCJpc1RyYWNraW5nIiwic2V0SXNUcmFja2luZyIsIndhdGNoSWRSZWYiLCJsYXN0V3JpdGVUaW1lUmVmIiwibGFzdFBvc2l0aW9uUmVmIiwic2hvdWxkVHJhY2siLCJjb3VyaWVyIiwiaXNPbmxpbmUiLCJjdXJyZW50IiwibmF2aWdhdG9yIiwiZ2VvbG9jYXRpb24iLCJjbGVhcldhdGNoIiwid2F0Y2hQb3NpdGlvbiIsInBvc2l0aW9uIiwibGF0aXR1ZGUiLCJsYXQiLCJsb25naXR1ZGUiLCJsbmciLCJoZWFkaW5nIiwiY29vcmRzIiwibm93IiwiRGF0ZSIsInRpbWVTaW5jZUxhc3RXcml0ZSIsInNob3VsZFdyaXRlIiwiZGlzdGFuY2UiLCJnZW9IYXNoIiwiZW5jb2RlIiwiZXJyb3IiLCJjb25zb2xlIiwiY29kZSIsIlBFUk1JU1NJT05fREVOSUVEIiwiZW5hYmxlSGlnaEFjY3VyYWN5IiwibWF4aW11bUFnZSIsInRpbWVvdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/v2/useCourierLocationWriter.ts\n"));

/***/ })

});