/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ngeohash@0.6.3";
exports.ids = ["vendor-chunks/ngeohash@0.6.3"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/ngeohash@0.6.3/node_modules/ngeohash/main.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/.pnpm/ngeohash@0.6.3/node_modules/ngeohash/main.js ***!
  \*****************************************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\nvar ENCODE_AUTO = 'auto';\n\nvar MIN_LAT = -90;\nvar MAX_LAT = 90;\nvar MIN_LON = -180;\nvar MAX_LON = 180;\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n\n  var chars = [],\n  bits = 0,\n  bitsTotal = 0,\n  hash_value = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var bitsTotal = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid,\n  combinedBits = 0;\n\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = (hashValue >> bits) & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON;\n\n  var latBit = 0, lonBit = 0;\n  var step = bitDepth / 2;\n\n  for (var i = 0; i < step; i++) {\n\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\n\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    }\n    else {\n      minLat = (maxLat + minLat) / 2;\n    }\n\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    }\n    else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\nfunction get_bit(bits, position) {\n  return (bits / Math.pow(2, position)) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n      error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude\n    + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude\n    + direction[1] * lonLat.error.longitude * 2;\n  neighborLon = ensure_valid_lon(neighborLon);\n  neighborLat = ensure_valid_lat(neighborLat);\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function (hash_int, direction, bitDepth) {\n    bitDepth = bitDepth || 52;\n    var lonlat = decode_int(hash_int, bitDepth);\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function (hash_string) {\n\n    var hashstringLength = hash_string.length;\n\n    var lonlat = decode(hash_string);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashList = [\n                            encodeNeighbor(1,0),\n                            encodeNeighbor(1,1),\n                            encodeNeighbor(0,1),\n                            encodeNeighbor(-1,1),\n                            encodeNeighbor(-1,0),\n                            encodeNeighbor(-1,-1),\n                            encodeNeighbor(0,-1),\n                            encodeNeighbor(1,-1)\n                            ];\n\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\n    }\n\n    return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function(hash_int, bitDepth){\n\n    bitDepth = bitDepth || 52;\n\n    var lonlat = decode_int(hash_int, bitDepth);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashIntList = [\n                               encodeNeighbor_int(1,0),\n                               encodeNeighbor_int(1,1),\n                               encodeNeighbor_int(0,1),\n                               encodeNeighbor_int(-1,1),\n                               encodeNeighbor_int(-1,0),\n                               encodeNeighbor_int(-1,-1),\n                               encodeNeighbor_int(0,-1),\n                               encodeNeighbor_int(1,-1)\n                               ];\n\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n    }\n\n    return neighborHashIntList;\n};\n\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n  var latLon = decode(hashSouthWest);\n\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n  var hashList = [];\n\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\n    bitDepth = bitDepth || 52;\n\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n\n    var latlon = decode_int(hashSouthWest, bitDepth);\n\n    var perLat = latlon.error.latitude * 2;\n    var perLon = latlon.error.longitude * 2;\n\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\n\n    var hashList = [];\n\n    for(var lat = 0; lat <= latStep; lat++){\n        for(var lon = 0; lon <= lonStep; lon++){\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\n        }\n    }\n\n  return hashList;\n};\n\nfunction ensure_valid_lon(lon) {\n  if (lon > MAX_LON)\n    return MIN_LON + lon % MAX_LON;\n  if (lon < MIN_LON)\n    return MAX_LON + lon % MAX_LON;\n  return lon;\n};\n\nfunction ensure_valid_lat(lat) {\n  if (lat > MAX_LAT)\n    return MAX_LAT;\n  if (lat < MIN_LAT)\n    return MIN_LAT;\n  return lat;\n};\n\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\n\nmodule.exports = geohash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25nZW9oYXNoQDAuNi4zL25vZGVfbW9kdWxlcy9uZ2VvaGFzaC9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBOztBQUVBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsVUFBVTs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQyxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLGdCQUFnQjtBQUNyQyx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhcGFkZXYvZGV2L2FwcHMvZ29zZW5kZXJyL25vZGVfbW9kdWxlcy8ucG5wbS9uZ2VvaGFzaEAwLjYuMy9ub2RlX21vZHVsZXMvbmdlb2hhc2gvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMSwgU3VuIE5pbmcuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LFxuICogbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqL1xuXG52YXIgQkFTRTMyX0NPREVTID0gXCIwMTIzNDU2Nzg5YmNkZWZnaGprbW5wcXJzdHV2d3h5elwiO1xudmFyIEJBU0UzMl9DT0RFU19ESUNUID0ge307XG5mb3IgKHZhciBpID0gMDsgaSA8IEJBU0UzMl9DT0RFUy5sZW5ndGg7IGkrKykge1xuICBCQVNFMzJfQ09ERVNfRElDVFtCQVNFMzJfQ09ERVMuY2hhckF0KGkpXSA9IGk7XG59XG5cbnZhciBFTkNPREVfQVVUTyA9ICdhdXRvJztcblxudmFyIE1JTl9MQVQgPSAtOTA7XG52YXIgTUFYX0xBVCA9IDkwO1xudmFyIE1JTl9MT04gPSAtMTgwO1xudmFyIE1BWF9MT04gPSAxODA7XG4vKipcbiAqIFNpZ25pZmljYW50IEZpZ3VyZSBIYXNoIExlbmd0aFxuICpcbiAqIFRoaXMgaXMgYSBxdWljayBhbmQgZGlydHkgbG9va3VwIHRvIGZpZ3VyZSBvdXQgaG93IGxvbmcgb3VyIGhhc2hcbiAqIHNob3VsZCBiZSBpbiBvcmRlciB0byBndWFyYW50ZWUgYSBjZXJ0YWluIGFtb3VudCBvZiB0cmFpbGluZ1xuICogc2lnbmlmaWNhbnQgZmlndXJlcy4gVGhpcyB3YXMgY2FsY3VsYXRlZCBieSBkZXRlcm1pbmluZyB0aGUgZXJyb3I6XG4gKiA0NS8yXihuLTEpIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiBiaXRzIGZvciBhIGxhdGl0dWRlIG9yXG4gKiBsb25naXR1ZGUuIEtleSBpcyAjIG9mIGRlc2lyZWQgc2lnIGZpZ3MsIHZhbHVlIGlzIG1pbmltdW0gbGVuZ3RoIG9mXG4gKiB0aGUgZ2VvaGFzaC5cbiAqIEB0eXBlIEFycmF5XG4gKi9cbi8vICAgICBEZXNpcmVkIHNpZyBmaWdzOiAgMCAgMSAgMiAgMyAgNCAgIDUgICA2ICAgNyAgIDggICA5ICAxMFxudmFyIFNJR0ZJR19IQVNIX0xFTkdUSCA9IFswLCA1LCA3LCA4LCAxMSwgMTIsIDEzLCAxNSwgMTYsIDE3LCAxOF07XG4vKipcbiAqIEVuY29kZVxuICpcbiAqIENyZWF0ZSBhIEdlb2hhc2ggb3V0IG9mIGEgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSB0aGF0IGlzXG4gKiBgbnVtYmVyT2ZDaGFyc2AgbG9uZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGxhdGl0dWRlXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGxvbmdpdHVkZVxuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlck9mQ2hhcnNcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAobGF0aXR1ZGUsIGxvbmdpdHVkZSwgbnVtYmVyT2ZDaGFycykge1xuICBpZiAobnVtYmVyT2ZDaGFycyA9PT0gRU5DT0RFX0FVVE8pIHtcbiAgICBpZiAodHlwZW9mKGxhdGl0dWRlKSA9PT0gJ251bWJlcicgfHwgdHlwZW9mKGxvbmdpdHVkZSkgPT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBub3RhdGlvbiByZXF1aXJlZCBmb3IgYXV0byBwcmVjaXNpb24uJyk7XG4gICAgfVxuICAgIHZhciBkZWNTaWdGaWdzTGF0ID0gbGF0aXR1ZGUuc3BsaXQoJy4nKVsxXS5sZW5ndGg7XG4gICAgdmFyIGRlY1NpZ0ZpZ3NMb25nID0gbG9uZ2l0dWRlLnNwbGl0KCcuJylbMV0ubGVuZ3RoO1xuICAgIHZhciBudW1iZXJPZlNpZ0ZpZ3MgPSBNYXRoLm1heChkZWNTaWdGaWdzTGF0LCBkZWNTaWdGaWdzTG9uZyk7XG4gICAgbnVtYmVyT2ZDaGFycyA9IFNJR0ZJR19IQVNIX0xFTkdUSFtudW1iZXJPZlNpZ0ZpZ3NdO1xuICB9IGVsc2UgaWYgKG51bWJlck9mQ2hhcnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG51bWJlck9mQ2hhcnMgPSA5O1xuICB9XG5cbiAgdmFyIGNoYXJzID0gW10sXG4gIGJpdHMgPSAwLFxuICBiaXRzVG90YWwgPSAwLFxuICBoYXNoX3ZhbHVlID0gMCxcbiAgbWF4TGF0ID0gTUFYX0xBVCxcbiAgbWluTGF0ID0gTUlOX0xBVCxcbiAgbWF4TG9uID0gTUFYX0xPTixcbiAgbWluTG9uID0gTUlOX0xPTixcbiAgbWlkO1xuICB3aGlsZSAoY2hhcnMubGVuZ3RoIDwgbnVtYmVyT2ZDaGFycykge1xuICAgIGlmIChiaXRzVG90YWwgJSAyID09PSAwKSB7XG4gICAgICBtaWQgPSAobWF4TG9uICsgbWluTG9uKSAvIDI7XG4gICAgICBpZiAobG9uZ2l0dWRlID4gbWlkKSB7XG4gICAgICAgIGhhc2hfdmFsdWUgPSAoaGFzaF92YWx1ZSA8PCAxKSArIDE7XG4gICAgICAgIG1pbkxvbiA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc2hfdmFsdWUgPSAoaGFzaF92YWx1ZSA8PCAxKSArIDA7XG4gICAgICAgIG1heExvbiA9IG1pZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWlkID0gKG1heExhdCArIG1pbkxhdCkgLyAyO1xuICAgICAgaWYgKGxhdGl0dWRlID4gbWlkKSB7XG4gICAgICAgIGhhc2hfdmFsdWUgPSAoaGFzaF92YWx1ZSA8PCAxKSArIDE7XG4gICAgICAgIG1pbkxhdCA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc2hfdmFsdWUgPSAoaGFzaF92YWx1ZSA8PCAxKSArIDA7XG4gICAgICAgIG1heExhdCA9IG1pZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiaXRzKys7XG4gICAgYml0c1RvdGFsKys7XG4gICAgaWYgKGJpdHMgPT09IDUpIHtcbiAgICAgIHZhciBjb2RlID0gQkFTRTMyX0NPREVTW2hhc2hfdmFsdWVdO1xuICAgICAgY2hhcnMucHVzaChjb2RlKTtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgaGFzaF92YWx1ZSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogRW5jb2RlIEludGVnZXJcbiAqXG4gKiBDcmVhdGUgYSBHZW9oYXNoIG91dCBvZiBhIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgdGhhdCBpcyBvZiAnYml0RGVwdGgnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsYXRpdHVkZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxvbmdpdHVkZVxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdERlcHRoXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG52YXIgZW5jb2RlX2ludCA9IGZ1bmN0aW9uIChsYXRpdHVkZSwgbG9uZ2l0dWRlLCBiaXREZXB0aCkge1xuXG4gIGJpdERlcHRoID0gYml0RGVwdGggfHwgNTI7XG5cbiAgdmFyIGJpdHNUb3RhbCA9IDAsXG4gIG1heExhdCA9IE1BWF9MQVQsXG4gIG1pbkxhdCA9IE1JTl9MQVQsXG4gIG1heExvbiA9IE1BWF9MT04sXG4gIG1pbkxvbiA9IE1JTl9MT04sXG4gIG1pZCxcbiAgY29tYmluZWRCaXRzID0gMDtcblxuICB3aGlsZSAoYml0c1RvdGFsIDwgYml0RGVwdGgpIHtcbiAgICBjb21iaW5lZEJpdHMgKj0gMjtcbiAgICBpZiAoYml0c1RvdGFsICUgMiA9PT0gMCkge1xuICAgICAgbWlkID0gKG1heExvbiArIG1pbkxvbikgLyAyO1xuICAgICAgaWYgKGxvbmdpdHVkZSA+IG1pZCkge1xuICAgICAgICBjb21iaW5lZEJpdHMgKz0gMTtcbiAgICAgICAgbWluTG9uID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4TG9uID0gbWlkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtaWQgPSAobWF4TGF0ICsgbWluTGF0KSAvIDI7XG4gICAgICBpZiAobGF0aXR1ZGUgPiBtaWQpIHtcbiAgICAgICAgY29tYmluZWRCaXRzICs9IDE7XG4gICAgICAgIG1pbkxhdCA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heExhdCA9IG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgYml0c1RvdGFsKys7XG4gIH1cbiAgcmV0dXJuIGNvbWJpbmVkQml0cztcbn07XG5cbi8qKlxuICogRGVjb2RlIEJvdW5kaW5nIEJveFxuICpcbiAqIERlY29kZSBoYXNoU3RyaW5nIGludG8gYSBib3VuZCBib3ggbWF0Y2hlcyBpdC4gRGF0YSByZXR1cm5lZCBpbiBhIGZvdXItZWxlbWVudCBhcnJheTogW21pbmxhdCwgbWlubG9uLCBtYXhsYXQsIG1heGxvbl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoX3N0cmluZ1xuICogQHJldHVybnMge0FycmF5fVxuICovXG52YXIgZGVjb2RlX2Jib3ggPSBmdW5jdGlvbiAoaGFzaF9zdHJpbmcpIHtcbiAgdmFyIGlzTG9uID0gdHJ1ZSxcbiAgICBtYXhMYXQgPSBNQVhfTEFULFxuICAgIG1pbkxhdCA9IE1JTl9MQVQsXG4gICAgbWF4TG9uID0gTUFYX0xPTixcbiAgICBtaW5Mb24gPSBNSU5fTE9OLFxuICAgIG1pZDtcblxuICB2YXIgaGFzaFZhbHVlID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYXNoX3N0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY29kZSA9IGhhc2hfc3RyaW5nW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgaGFzaFZhbHVlID0gQkFTRTMyX0NPREVTX0RJQ1RbY29kZV07XG5cbiAgICBmb3IgKHZhciBiaXRzID0gNDsgYml0cyA+PSAwOyBiaXRzLS0pIHtcbiAgICAgIHZhciBiaXQgPSAoaGFzaFZhbHVlID4+IGJpdHMpICYgMTtcbiAgICAgIGlmIChpc0xvbikge1xuICAgICAgICBtaWQgPSAobWF4TG9uICsgbWluTG9uKSAvIDI7XG4gICAgICAgIGlmIChiaXQgPT09IDEpIHtcbiAgICAgICAgICBtaW5Mb24gPSBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4TG9uID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaWQgPSAobWF4TGF0ICsgbWluTGF0KSAvIDI7XG4gICAgICAgIGlmIChiaXQgPT09IDEpIHtcbiAgICAgICAgICBtaW5MYXQgPSBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4TGF0ID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc0xvbiA9ICFpc0xvbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFttaW5MYXQsIG1pbkxvbiwgbWF4TGF0LCBtYXhMb25dO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgQm91bmRpbmcgQm94IEludGVnZXJcbiAqXG4gKiBEZWNvZGUgaGFzaCBudW1iZXIgaW50byBhIGJvdW5kIGJveCBtYXRjaGVzIGl0LiBEYXRhIHJldHVybmVkIGluIGEgZm91ci1lbGVtZW50IGFycmF5OiBbbWlubGF0LCBtaW5sb24sIG1heGxhdCwgbWF4bG9uXVxuICogQHBhcmFtIHtOdW1iZXJ9IGhhc2hJbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBiaXREZXB0aFxuICogQHJldHVybnMge0FycmF5fVxuICovXG52YXIgZGVjb2RlX2Jib3hfaW50ID0gZnVuY3Rpb24gKGhhc2hJbnQsIGJpdERlcHRoKSB7XG5cbiAgYml0RGVwdGggPSBiaXREZXB0aCB8fCA1MjtcblxuICB2YXIgbWF4TGF0ID0gTUFYX0xBVCxcbiAgbWluTGF0ID0gTUlOX0xBVCxcbiAgbWF4TG9uID0gTUFYX0xPTixcbiAgbWluTG9uID0gTUlOX0xPTjtcblxuICB2YXIgbGF0Qml0ID0gMCwgbG9uQml0ID0gMDtcbiAgdmFyIHN0ZXAgPSBiaXREZXB0aCAvIDI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwOyBpKyspIHtcblxuICAgIGxvbkJpdCA9IGdldF9iaXQoaGFzaEludCwgKChzdGVwIC0gaSkgKiAyKSAtIDEpO1xuICAgIGxhdEJpdCA9IGdldF9iaXQoaGFzaEludCwgKChzdGVwIC0gaSkgKiAyKSAtIDIpO1xuXG4gICAgaWYgKGxhdEJpdCA9PT0gMCkge1xuICAgICAgbWF4TGF0ID0gKG1heExhdCArIG1pbkxhdCkgLyAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG1pbkxhdCA9IChtYXhMYXQgKyBtaW5MYXQpIC8gMjtcbiAgICB9XG5cbiAgICBpZiAobG9uQml0ID09PSAwKSB7XG4gICAgICBtYXhMb24gPSAobWF4TG9uICsgbWluTG9uKSAvIDI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbWluTG9uID0gKG1heExvbiArIG1pbkxvbikgLyAyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW21pbkxhdCwgbWluTG9uLCBtYXhMYXQsIG1heExvbl07XG59O1xuXG5mdW5jdGlvbiBnZXRfYml0KGJpdHMsIHBvc2l0aW9uKSB7XG4gIHJldHVybiAoYml0cyAvIE1hdGgucG93KDIsIHBvc2l0aW9uKSkgJiAweDAxO1xufVxuXG4vKipcbiAqIERlY29kZVxuICpcbiAqIERlY29kZSBhIGhhc2ggc3RyaW5nIGludG8gcGFpciBvZiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLiBBIGphdmFzY3JpcHQgb2JqZWN0IGlzIHJldHVybmVkIHdpdGgga2V5cyBgbGF0aXR1ZGVgLFxuICogYGxvbmdpdHVkZWAgYW5kIGBlcnJvcmAuXG4gKiBAcGFyYW0ge1N0cmluZ30gaGFzaFN0cmluZ1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xudmFyIGRlY29kZSA9IGZ1bmN0aW9uIChoYXNoU3RyaW5nKSB7XG4gIHZhciBiYm94ID0gZGVjb2RlX2Jib3goaGFzaFN0cmluZyk7XG4gIHZhciBsYXQgPSAoYmJveFswXSArIGJib3hbMl0pIC8gMjtcbiAgdmFyIGxvbiA9IChiYm94WzFdICsgYmJveFszXSkgLyAyO1xuICB2YXIgbGF0RXJyID0gYmJveFsyXSAtIGxhdDtcbiAgdmFyIGxvbkVyciA9IGJib3hbM10gLSBsb247XG4gIHJldHVybiB7bGF0aXR1ZGU6IGxhdCwgbG9uZ2l0dWRlOiBsb24sXG4gICAgICBlcnJvcjoge2xhdGl0dWRlOiBsYXRFcnIsIGxvbmdpdHVkZTogbG9uRXJyfX07XG59O1xuXG4vKipcbiAqIERlY29kZSBJbnRlZ2VyXG4gKlxuICogRGVjb2RlIGEgaGFzaCBudW1iZXIgaW50byBwYWlyIG9mIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuIEEgamF2YXNjcmlwdCBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCBrZXlzIGBsYXRpdHVkZWAsXG4gKiBgbG9uZ2l0dWRlYCBhbmQgYGVycm9yYC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoYXNoX2ludFxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdERlcHRoXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG52YXIgZGVjb2RlX2ludCA9IGZ1bmN0aW9uIChoYXNoX2ludCwgYml0RGVwdGgpIHtcbiAgdmFyIGJib3ggPSBkZWNvZGVfYmJveF9pbnQoaGFzaF9pbnQsIGJpdERlcHRoKTtcbiAgdmFyIGxhdCA9IChiYm94WzBdICsgYmJveFsyXSkgLyAyO1xuICB2YXIgbG9uID0gKGJib3hbMV0gKyBiYm94WzNdKSAvIDI7XG4gIHZhciBsYXRFcnIgPSBiYm94WzJdIC0gbGF0O1xuICB2YXIgbG9uRXJyID0gYmJveFszXSAtIGxvbjtcbiAgcmV0dXJuIHtsYXRpdHVkZTogbGF0LCBsb25naXR1ZGU6IGxvbixcbiAgICAgICAgICBlcnJvcjoge2xhdGl0dWRlOiBsYXRFcnIsIGxvbmdpdHVkZTogbG9uRXJyfX07XG59O1xuXG4vKipcbiAqIE5laWdoYm9yXG4gKlxuICogRmluZCBuZWlnaGJvciBvZiBhIGdlb2hhc2ggc3RyaW5nIGluIGNlcnRhaW4gZGlyZWN0aW9uLiBEaXJlY3Rpb24gaXMgYSB0d28tZWxlbWVudCBhcnJheSwgaS5lLiBbMSwwXSBtZWFucyBub3J0aCwgWy0xLC0xXSBtZWFucyBzb3V0aHdlc3QuXG4gKiBkaXJlY3Rpb24gW2xhdCwgbG9uXSwgaS5lLlxuICogWzEsMF0gLSBub3J0aFxuICogWzEsMV0gLSBub3J0aGVhc3RcbiAqIC4uLlxuICogQHBhcmFtIHtTdHJpbmd9IGhhc2hTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IERpcmVjdGlvbiBhcyBhIDJEIG5vcm1hbGl6ZWQgdmVjdG9yLlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xudmFyIG5laWdoYm9yID0gZnVuY3Rpb24gKGhhc2hTdHJpbmcsIGRpcmVjdGlvbikge1xuICB2YXIgbG9uTGF0ID0gZGVjb2RlKGhhc2hTdHJpbmcpO1xuICB2YXIgbmVpZ2hib3JMYXQgPSBsb25MYXQubGF0aXR1ZGVcbiAgICArIGRpcmVjdGlvblswXSAqIGxvbkxhdC5lcnJvci5sYXRpdHVkZSAqIDI7XG4gIHZhciBuZWlnaGJvckxvbiA9IGxvbkxhdC5sb25naXR1ZGVcbiAgICArIGRpcmVjdGlvblsxXSAqIGxvbkxhdC5lcnJvci5sb25naXR1ZGUgKiAyO1xuICBuZWlnaGJvckxvbiA9IGVuc3VyZV92YWxpZF9sb24obmVpZ2hib3JMb24pO1xuICBuZWlnaGJvckxhdCA9IGVuc3VyZV92YWxpZF9sYXQobmVpZ2hib3JMYXQpO1xuICByZXR1cm4gZW5jb2RlKG5laWdoYm9yTGF0LCBuZWlnaGJvckxvbiwgaGFzaFN0cmluZy5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBOZWlnaGJvciBJbnRlZ2VyXG4gKlxuICogRmluZCBuZWlnaGJvciBvZiBhIGdlb2hhc2ggaW50ZWdlciBpbiBjZXJ0YWluIGRpcmVjdGlvbi4gRGlyZWN0aW9uIGlzIGEgdHdvLWVsZW1lbnQgYXJyYXksIGkuZS4gWzEsMF0gbWVhbnMgbm9ydGgsIFstMSwtMV0gbWVhbnMgc291dGh3ZXN0LlxuICogZGlyZWN0aW9uIFtsYXQsIGxvbl0sIGkuZS5cbiAqIFsxLDBdIC0gbm9ydGhcbiAqIFsxLDFdIC0gbm9ydGhlYXN0XG4gKiAuLi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoX3N0cmluZ1xuICogQHJldHVybnMge0FycmF5fVxuKi9cbnZhciBuZWlnaGJvcl9pbnQgPSBmdW5jdGlvbiAoaGFzaF9pbnQsIGRpcmVjdGlvbiwgYml0RGVwdGgpIHtcbiAgICBiaXREZXB0aCA9IGJpdERlcHRoIHx8IDUyO1xuICAgIHZhciBsb25sYXQgPSBkZWNvZGVfaW50KGhhc2hfaW50LCBiaXREZXB0aCk7XG4gICAgdmFyIG5laWdoYm9yX2xhdCA9IGxvbmxhdC5sYXRpdHVkZSArIGRpcmVjdGlvblswXSAqIGxvbmxhdC5lcnJvci5sYXRpdHVkZSAqIDI7XG4gICAgdmFyIG5laWdoYm9yX2xvbiA9IGxvbmxhdC5sb25naXR1ZGUgKyBkaXJlY3Rpb25bMV0gKiBsb25sYXQuZXJyb3IubG9uZ2l0dWRlICogMjtcbiAgICBuZWlnaGJvcl9sb24gPSBlbnN1cmVfdmFsaWRfbG9uKG5laWdoYm9yX2xvbik7XG4gICAgbmVpZ2hib3JfbGF0ID0gZW5zdXJlX3ZhbGlkX2xhdChuZWlnaGJvcl9sYXQpO1xuICAgIHJldHVybiBlbmNvZGVfaW50KG5laWdoYm9yX2xhdCwgbmVpZ2hib3JfbG9uLCBiaXREZXB0aCk7XG59O1xuXG4vKipcbiAqIE5laWdoYm9yc1xuICpcbiAqIFJldHVybnMgYWxsIG5laWdoYm9ycycgaGFzaHN0cmluZ3MgY2xvY2t3aXNlIGZyb20gbm9ydGggYXJvdW5kIHRvIG5vcnRod2VzdFxuICogNyAwIDFcbiAqIDYgeCAyXG4gKiA1IDQgM1xuICogQHBhcmFtIHtTdHJpbmd9IGhhc2hfc3RyaW5nXG4gKiBAcmV0dXJucyB7ZW5jb2RlZCBuZWlnaGJvckhhc2hMaXN0fEFycmF5fVxuICovXG52YXIgbmVpZ2hib3JzID0gZnVuY3Rpb24gKGhhc2hfc3RyaW5nKSB7XG5cbiAgICB2YXIgaGFzaHN0cmluZ0xlbmd0aCA9IGhhc2hfc3RyaW5nLmxlbmd0aDtcblxuICAgIHZhciBsb25sYXQgPSBkZWNvZGUoaGFzaF9zdHJpbmcpO1xuICAgIHZhciBsYXQgPSBsb25sYXQubGF0aXR1ZGU7XG4gICAgdmFyIGxvbiA9IGxvbmxhdC5sb25naXR1ZGU7XG4gICAgdmFyIGxhdEVyciA9IGxvbmxhdC5lcnJvci5sYXRpdHVkZSAqIDI7XG4gICAgdmFyIGxvbkVyciA9IGxvbmxhdC5lcnJvci5sb25naXR1ZGUgKiAyO1xuXG4gICAgdmFyIG5laWdoYm9yX2xhdCxcbiAgICAgICAgbmVpZ2hib3JfbG9uO1xuXG4gICAgdmFyIG5laWdoYm9ySGFzaExpc3QgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3IoMSwwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVOZWlnaGJvcigxLDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZU5laWdoYm9yKDAsMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3IoLTEsMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3IoLTEsMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3IoLTEsLTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZU5laWdoYm9yKDAsLTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZU5laWdoYm9yKDEsLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgIGZ1bmN0aW9uIGVuY29kZU5laWdoYm9yKG5laWdoYm9yTGF0RGlyLCBuZWlnaGJvckxvbkRpcil7XG4gICAgICAgIG5laWdoYm9yX2xhdCA9IGxhdCArIG5laWdoYm9yTGF0RGlyICogbGF0RXJyO1xuICAgICAgICBuZWlnaGJvcl9sb24gPSBsb24gKyBuZWlnaGJvckxvbkRpciAqIGxvbkVycjtcbiAgICAgICAgbmVpZ2hib3JfbG9uID0gZW5zdXJlX3ZhbGlkX2xvbihuZWlnaGJvcl9sb24pO1xuICAgICAgICBuZWlnaGJvcl9sYXQgPSBlbnN1cmVfdmFsaWRfbGF0KG5laWdoYm9yX2xhdCk7XG4gICAgICAgIHJldHVybiBlbmNvZGUobmVpZ2hib3JfbGF0LCBuZWlnaGJvcl9sb24sIGhhc2hzdHJpbmdMZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZWlnaGJvckhhc2hMaXN0O1xufTtcblxuLyoqXG4gKiBOZWlnaGJvcnMgSW50ZWdlclxuICpcbiAqIFJldHVybnMgYWxsIG5laWdoYm9ycycgaGFzaCBpbnRlZ2VycyBjbG9ja3dpc2UgZnJvbSBub3J0aCBhcm91bmQgdG8gbm9ydGh3ZXN0XG4gKiA3IDAgMVxuICogNiB4IDJcbiAqIDUgNCAzXG4gKiBAcGFyYW0ge051bWJlcn0gaGFzaF9pbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBiaXREZXB0aFxuICogQHJldHVybnMge2VuY29kZV9pbnQnZCBuZWlnaGJvckhhc2hJbnRMaXN0fEFycmF5fVxuICovXG52YXIgbmVpZ2hib3JzX2ludCA9IGZ1bmN0aW9uKGhhc2hfaW50LCBiaXREZXB0aCl7XG5cbiAgICBiaXREZXB0aCA9IGJpdERlcHRoIHx8IDUyO1xuXG4gICAgdmFyIGxvbmxhdCA9IGRlY29kZV9pbnQoaGFzaF9pbnQsIGJpdERlcHRoKTtcbiAgICB2YXIgbGF0ID0gbG9ubGF0LmxhdGl0dWRlO1xuICAgIHZhciBsb24gPSBsb25sYXQubG9uZ2l0dWRlO1xuICAgIHZhciBsYXRFcnIgPSBsb25sYXQuZXJyb3IubGF0aXR1ZGUgKiAyO1xuICAgIHZhciBsb25FcnIgPSBsb25sYXQuZXJyb3IubG9uZ2l0dWRlICogMjtcblxuICAgIHZhciBuZWlnaGJvcl9sYXQsXG4gICAgICAgIG5laWdoYm9yX2xvbjtcblxuICAgIHZhciBuZWlnaGJvckhhc2hJbnRMaXN0ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZU5laWdoYm9yX2ludCgxLDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZU5laWdoYm9yX2ludCgxLDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZU5laWdoYm9yX2ludCgwLDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZU5laWdoYm9yX2ludCgtMSwxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVOZWlnaGJvcl9pbnQoLTEsMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3JfaW50KC0xLC0xKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVOZWlnaGJvcl9pbnQoMCwtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlTmVpZ2hib3JfaW50KDEsLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgIGZ1bmN0aW9uIGVuY29kZU5laWdoYm9yX2ludChuZWlnaGJvckxhdERpciwgbmVpZ2hib3JMb25EaXIpe1xuICAgICAgICBuZWlnaGJvcl9sYXQgPSBsYXQgKyBuZWlnaGJvckxhdERpciAqIGxhdEVycjtcbiAgICAgICAgbmVpZ2hib3JfbG9uID0gbG9uICsgbmVpZ2hib3JMb25EaXIgKiBsb25FcnI7XG4gICAgICAgIG5laWdoYm9yX2xvbiA9IGVuc3VyZV92YWxpZF9sb24obmVpZ2hib3JfbG9uKTtcbiAgICAgICAgbmVpZ2hib3JfbGF0ID0gZW5zdXJlX3ZhbGlkX2xhdChuZWlnaGJvcl9sYXQpO1xuICAgICAgICByZXR1cm4gZW5jb2RlX2ludChuZWlnaGJvcl9sYXQsIG5laWdoYm9yX2xvbiwgYml0RGVwdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZWlnaGJvckhhc2hJbnRMaXN0O1xufTtcblxuXG4vKipcbiAqIEJvdW5kaW5nIEJveGVzXG4gKlxuICogUmV0dXJuIGFsbCB0aGUgaGFzaFN0cmluZyBiZXR3ZWVuIG1pbkxhdCwgbWluTG9uLCBtYXhMYXQsIG1heExvbiBpbiBudW1iZXJPZkNoYXJzXG4gKiBAcGFyYW0ge051bWJlcn0gbWluTGF0XG4gKiBAcGFyYW0ge051bWJlcn0gbWluTG9uXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TGF0XG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TG9uXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyT2ZDaGFyc1xuICogQHJldHVybnMge2Jib3hlcy5oYXNoTGlzdHxBcnJheX1cbiAqL1xudmFyIGJib3hlcyA9IGZ1bmN0aW9uIChtaW5MYXQsIG1pbkxvbiwgbWF4TGF0LCBtYXhMb24sIG51bWJlck9mQ2hhcnMpIHtcbiAgbnVtYmVyT2ZDaGFycyA9IG51bWJlck9mQ2hhcnMgfHwgOTtcblxuICB2YXIgaGFzaFNvdXRoV2VzdCA9IGVuY29kZShtaW5MYXQsIG1pbkxvbiwgbnVtYmVyT2ZDaGFycyk7XG4gIHZhciBoYXNoTm9ydGhFYXN0ID0gZW5jb2RlKG1heExhdCwgbWF4TG9uLCBudW1iZXJPZkNoYXJzKTtcblxuICB2YXIgbGF0TG9uID0gZGVjb2RlKGhhc2hTb3V0aFdlc3QpO1xuXG4gIHZhciBwZXJMYXQgPSBsYXRMb24uZXJyb3IubGF0aXR1ZGUgKiAyO1xuICB2YXIgcGVyTG9uID0gbGF0TG9uLmVycm9yLmxvbmdpdHVkZSAqIDI7XG5cbiAgdmFyIGJveFNvdXRoV2VzdCA9IGRlY29kZV9iYm94KGhhc2hTb3V0aFdlc3QpO1xuICB2YXIgYm94Tm9ydGhFYXN0ID0gZGVjb2RlX2Jib3goaGFzaE5vcnRoRWFzdCk7XG5cbiAgdmFyIGxhdFN0ZXAgPSBNYXRoLnJvdW5kKChib3hOb3J0aEVhc3RbMF0gLSBib3hTb3V0aFdlc3RbMF0pIC8gcGVyTGF0KTtcbiAgdmFyIGxvblN0ZXAgPSBNYXRoLnJvdW5kKChib3hOb3J0aEVhc3RbMV0gLSBib3hTb3V0aFdlc3RbMV0pIC8gcGVyTG9uKTtcblxuICB2YXIgaGFzaExpc3QgPSBbXTtcblxuICBmb3IgKHZhciBsYXQgPSAwOyBsYXQgPD0gbGF0U3RlcDsgbGF0KyspIHtcbiAgICBmb3IgKHZhciBsb24gPSAwOyBsb24gPD0gbG9uU3RlcDsgbG9uKyspIHtcbiAgICAgIGhhc2hMaXN0LnB1c2gobmVpZ2hib3IoaGFzaFNvdXRoV2VzdCwgW2xhdCwgbG9uXSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNoTGlzdDtcbn07XG5cbi8qKlxuICogQm91bmRpbmcgQm94ZXMgSW50ZWdlclxuICpcbiAqIFJldHVybiBhbGwgdGhlIGhhc2ggaW50ZWdlcnMgYmV0d2VlbiBtaW5MYXQsIG1pbkxvbiwgbWF4TGF0LCBtYXhMb24gaW4gYml0RGVwdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5MYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5Mb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBiaXREZXB0aFxuICogQHJldHVybnMge2Jib3hlc19pbnQuaGFzaExpc3R8QXJyYXl9XG4gKi9cbnZhciBiYm94ZXNfaW50ID0gZnVuY3Rpb24obWluTGF0LCBtaW5Mb24sIG1heExhdCwgbWF4TG9uLCBiaXREZXB0aCl7XG4gICAgYml0RGVwdGggPSBiaXREZXB0aCB8fCA1MjtcblxuICAgIHZhciBoYXNoU291dGhXZXN0ID0gZW5jb2RlX2ludChtaW5MYXQsIG1pbkxvbiwgYml0RGVwdGgpO1xuICAgIHZhciBoYXNoTm9ydGhFYXN0ID0gZW5jb2RlX2ludChtYXhMYXQsIG1heExvbiwgYml0RGVwdGgpO1xuXG4gICAgdmFyIGxhdGxvbiA9IGRlY29kZV9pbnQoaGFzaFNvdXRoV2VzdCwgYml0RGVwdGgpO1xuXG4gICAgdmFyIHBlckxhdCA9IGxhdGxvbi5lcnJvci5sYXRpdHVkZSAqIDI7XG4gICAgdmFyIHBlckxvbiA9IGxhdGxvbi5lcnJvci5sb25naXR1ZGUgKiAyO1xuXG4gICAgdmFyIGJveFNvdXRoV2VzdCA9IGRlY29kZV9iYm94X2ludChoYXNoU291dGhXZXN0LCBiaXREZXB0aCk7XG4gICAgdmFyIGJveE5vcnRoRWFzdCA9IGRlY29kZV9iYm94X2ludChoYXNoTm9ydGhFYXN0LCBiaXREZXB0aCk7XG5cbiAgICB2YXIgbGF0U3RlcCA9IE1hdGgucm91bmQoKGJveE5vcnRoRWFzdFswXSAtIGJveFNvdXRoV2VzdFswXSkvcGVyTGF0KTtcbiAgICB2YXIgbG9uU3RlcCA9IE1hdGgucm91bmQoKGJveE5vcnRoRWFzdFsxXSAtIGJveFNvdXRoV2VzdFsxXSkvcGVyTG9uKTtcblxuICAgIHZhciBoYXNoTGlzdCA9IFtdO1xuXG4gICAgZm9yKHZhciBsYXQgPSAwOyBsYXQgPD0gbGF0U3RlcDsgbGF0Kyspe1xuICAgICAgICBmb3IodmFyIGxvbiA9IDA7IGxvbiA8PSBsb25TdGVwOyBsb24rKyl7XG4gICAgICAgICAgICBoYXNoTGlzdC5wdXNoKG5laWdoYm9yX2ludChoYXNoU291dGhXZXN0LFtsYXQsIGxvbl0sIGJpdERlcHRoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgcmV0dXJuIGhhc2hMaXN0O1xufTtcblxuZnVuY3Rpb24gZW5zdXJlX3ZhbGlkX2xvbihsb24pIHtcbiAgaWYgKGxvbiA+IE1BWF9MT04pXG4gICAgcmV0dXJuIE1JTl9MT04gKyBsb24gJSBNQVhfTE9OO1xuICBpZiAobG9uIDwgTUlOX0xPTilcbiAgICByZXR1cm4gTUFYX0xPTiArIGxvbiAlIE1BWF9MT047XG4gIHJldHVybiBsb247XG59O1xuXG5mdW5jdGlvbiBlbnN1cmVfdmFsaWRfbGF0KGxhdCkge1xuICBpZiAobGF0ID4gTUFYX0xBVClcbiAgICByZXR1cm4gTUFYX0xBVDtcbiAgaWYgKGxhdCA8IE1JTl9MQVQpXG4gICAgcmV0dXJuIE1JTl9MQVQ7XG4gIHJldHVybiBsYXQ7XG59O1xuXG52YXIgZ2VvaGFzaCA9IHtcbiAgJ0VOQ09ERV9BVVRPJzogRU5DT0RFX0FVVE8sXG4gICdlbmNvZGUnOiBlbmNvZGUsXG4gICdlbmNvZGVfdWludDY0JzogZW5jb2RlX2ludCwgLy8ga2VlcGluZyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdpbGwgZGVwcmVjYXRlXG4gICdlbmNvZGVfaW50JzogZW5jb2RlX2ludCxcbiAgJ2RlY29kZSc6IGRlY29kZSxcbiAgJ2RlY29kZV9pbnQnOiBkZWNvZGVfaW50LFxuICAnZGVjb2RlX3VpbnQ2NCc6IGRlY29kZV9pbnQsIC8vIGtlZXBpbmcgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3aWxsIGRlcHJlY2F0ZVxuICAnZGVjb2RlX2Jib3gnOiBkZWNvZGVfYmJveCxcbiAgJ2RlY29kZV9iYm94X3VpbnQ2NCc6IGRlY29kZV9iYm94X2ludCwgLy8ga2VlcGluZyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdpbGwgZGVwcmVjYXRlXG4gICdkZWNvZGVfYmJveF9pbnQnOiBkZWNvZGVfYmJveF9pbnQsXG4gICduZWlnaGJvcic6IG5laWdoYm9yLFxuICAnbmVpZ2hib3JfaW50JzogbmVpZ2hib3JfaW50LFxuICAnbmVpZ2hib3JzJzogbmVpZ2hib3JzLFxuICAnbmVpZ2hib3JzX2ludCc6IG5laWdoYm9yc19pbnQsXG4gICdiYm94ZXMnOiBiYm94ZXMsXG4gICdiYm94ZXNfaW50JzogYmJveGVzX2ludFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW9oYXNoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/ngeohash@0.6.3/node_modules/ngeohash/main.js\n");

/***/ })

};
;