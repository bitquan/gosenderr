rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ========== HELPER FUNCTIONS ==========
    
    function signedIn() {
      return request.auth != null;
    }

    function isSelf(uid) {
      return signedIn() && request.auth.uid == uid;
    }
    
    function isAdmin() {
      return signedIn() && (
        request.auth.token.get('role', '') == 'admin' ||
        request.auth.token.get('admin', false) == true ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin'
      );
    }
    
    function isCourier() {
      return signedIn() && (
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'courier' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('courierProfile', null) != null
      );
    }
    
    function isPackageRunner() {
      return signedIn() && request.auth.token.get('packageRunner', false) == true;
    }
    
    function isVendor() {
      return signedIn() && (
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'vendor' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('vendorProfile', null) != null
      );
    }
    
    function validRole(role) {
      return role in ['buyer', 'seller', 'courier', 'admin', 'customer', 'runner', 'vendor', 'package_runner'];
    }
    
    function validNonAdminRole(role) {
      return role in ['buyer', 'seller', 'courier', 'customer', 'runner', 'vendor', 'package_runner'];
    }

    function validJobStatus(s) {
      return s in ['open', 'pending', 'assigned', 'in_progress', 'enroute_pickup', 'arrived_pickup', 'picked_up', 
                   'enroute_dropoff', 'arrived_dropoff', 'completed', 'cancelled', 'disputed'];
    }

    function validPackageSize(size) {
      return size in ['small', 'medium', 'large', 'xl'];
    }

    function validPackageFlags(flags) {
      return flags == null || (
        flags is map
        && (!('needsSuvVan' in flags) || flags.needsSuvVan is bool)
        && (!('fragile' in flags) || flags.fragile is bool)
        && (!('heavyTwoPerson' in flags) || flags.heavyTwoPerson is bool)
        && (!('oversized' in flags) || flags.oversized is bool)
        && (!('stairs' in flags) || flags.stairs is bool)
      );
    }

    function validPackageInfo(pkg) {
      return pkg is map
        && validPackageSize(pkg.size)
        && validPackageFlags(pkg.get('flags', null))
        && (!('notes' in pkg) || (pkg.notes is string && pkg.notes.size() <= 300));
    }
    
    function validItemCategory(cat) {
      return cat in ['electronics', 'furniture', 'clothing', 'food', 'other'];
    }
    
    function validItemCondition(cond) {
      return cond in ['new', 'like_new', 'good', 'fair', 'poor'];
    }
    
    function validItemStatus(status) {
      return status in ['available', 'pending', 'sold'];
    }

    // ========== USERS ==========
    match /users/{uid} {
      // Anyone can read user documents (for marketplace, tracking, etc)
      allow read: if true;
      
      // Users can create their own document (but NOT with admin role)
      allow create: if isSelf(uid) && validNonAdminRole(request.resource.data.role);
      
      // Users can update their own document (but cannot change role to admin)
      allow update: if isSelf(uid) && (!('role' in request.resource.data) || validNonAdminRole(request.resource.data.role));
      
      // Admins can do everything
      allow read, write: if isAdmin();
      
      allow delete: if false;
    }

    // ========== ADMIN FLOW LOGS (Test-only run logs) ==========
    match /adminFlowLogs/{logId} {
      // Only admins can read run logs
      allow read: if isAdmin();
      // creation is performed by server/cloud functions; disallow client create
      allow create: if false;
      allow update: if false;
      allow delete: if isAdmin();

      match /entries/{entryId} {
        // Only admins can read run log entries
        allow read: if isAdmin();
        allow create: if false;
        allow update: if false;
        allow delete: if false;
      }
    }

    // ========== ITEMS (Marketplace) ==========
    match /items/{itemId} {
      // Anyone can read available items (public marketplace)
      allow read: if true;
      
      // Any user can create items (they become the seller)
      allow create: if signedIn()
        && request.resource.data.sellerId == request.auth.uid
        && validItemCategory(request.resource.data.category)
        && validItemCondition(request.resource.data.condition)
        && validItemStatus(request.resource.data.status)
        && request.resource.data.photos is list
        && request.resource.data.photos.size() <= 10;
      
      // Only seller can update/delete their items
      allow update, delete: if signedIn() && resource.data.sellerId == request.auth.uid;
      
      // Admins can read/update/delete any item
      allow read, update, delete: if isAdmin();
    }

    // ========== MARKETPLACE ORDERS ==========
    match /marketplaceOrders/{orderId} {
      function isSeller() {
        return signedIn() && resource.data.sellerId == request.auth.uid;
      }

      function isBuyer() {
        return signedIn() && resource.data.buyerId == request.auth.uid;
      }
      
      function validOrderStatus(status) {
        return status in ['payment_pending', 'paid', 'preparing', 'ready_for_pickup', 'in_transit', 'delivered', 'cancelled'];
      }
      
      function validStatusTransition() {
        return (
          (resource.data.status == 'payment_pending' && request.resource.data.status in ['paid', 'cancelled']) ||
          (resource.data.status == 'paid' && request.resource.data.status in ['preparing', 'cancelled']) ||
          (resource.data.status == 'preparing' && request.resource.data.status in ['ready_for_pickup', 'cancelled']) ||
          (resource.data.status == 'ready_for_pickup' && request.resource.data.status in ['in_transit', 'cancelled']) ||
          (resource.data.status == 'in_transit' && request.resource.data.status == 'delivered') ||
          (resource.data.status == 'delivered' && request.resource.data.status == 'delivered')
        );
      }

      // Seller or buyer can read their orders
      allow read: if isSeller() || isBuyer() || isAdmin();

      // Buyer creates order
      allow create: if signedIn()
        && request.resource.data.buyerId == request.auth.uid
        && request.resource.data.sellerId is string
        && validOrderStatus(request.resource.data.status);

      // Seller updates order status; buyer can attach checkout session metadata and payment info
      allow update: if signedIn() && (
        (
          isSeller()
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'status',
            'updatedAt'
          ])
          && validStatusTransition()
        )
        ||
        (
          isBuyer()
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'checkoutSessionId',
            'status',
            'paymentStatus',
            'jobId',
            'updatedAt'
          ])
          && validStatusTransition()
        )
        || isAdmin()
      );

      allow delete: if isAdmin();
    }

    // ========== DELIVERY JOBS ==========
    match /deliveryJobs/{jobId} {
      function isCustomer() {
        return signedIn() && resource.data.customerId == request.auth.uid;
      }
      
      function isSeller() {
        return signedIn() && resource.data.sellerId == request.auth.uid;
      }

      function isJobCourier() {
        return signedIn() && resource.data.get('courierId', null) == request.auth.uid;
      }
      
      function courierHasRequiredEquipment() {
        return request.resource.data.get('jobType', '') != 'food' || (
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data
            .get('courierProfile', {})
            .get('equipment', {})
            .get('cooler', {})
            .get('approved', false) == true
          ||
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data
            .get('courierProfile', {})
            .get('equipment', {})
            .get('hot_bag', {})
            .get('approved', false) == true
        );
      }
      
      function isParticipant() {
        return isCustomer() || isSeller() || isJobCourier();
      }
      
      // Read: customer, seller, courier, or admin
      allow read: if signedIn() && (isParticipant() || isAdmin());
      
      // Create: customer or seller can create delivery jobs
      allow create: if signedIn()
        && (request.resource.data.customerId == request.auth.uid || request.resource.data.sellerId == request.auth.uid)
        && request.resource.data.status == 'open'
        && request.resource.data.get('courierId', null) == null
        && validJobStatus(request.resource.data.status)
        && request.resource.data.jobType in ['package', 'food'];
      
      // Update: various scenarios
      allow update: if signedIn() && (
        // 1) Customer/Seller can cancel if status is 'open' or 'assigned'
        (
          (isCustomer() || isSeller())
          && request.resource.data.status == 'cancelled'
          && resource.data.status in ['open', 'assigned']
        )
        ||
        // 2) Any courier with proper equipment can claim an open job
        (
          resource.data.status == 'open'
          && resource.data.get('courierId', null) == null
          && request.resource.data.courierId == request.auth.uid
          && request.resource.data.status == 'assigned'
          && isCourier()
          && courierHasRequiredEquipment()
        )
        ||
        // 3) Assigned courier can update job progress
        (
          isJobCourier()
          && validJobStatus(request.resource.data.status)
        )
        ||
        // 4) Customer can confirm delivery or dispute
        (
          isCustomer()
          && resource.data.status == 'completed'
          && (
            // Confirm receipt
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['customerConfirmation', 'updatedAt'])
            ||
            // Open dispute
            request.resource.data.status == 'disputed'
          )
        )
        ||
        // 5) Admin can update any job
        isAdmin()
      );
      
      allow delete: if false;
    }

    // ========== LEGACY JOBS (backward compatibility) ==========
    match /jobs/{jobId} {
      function isCreator() {
        return signedIn() && resource.data.createdByUid == request.auth.uid;
      }

      function isAssignedCourier() {
        return signedIn() && resource.data.courierUid == request.auth.uid;
      }

      // create job: must be signed in and set createdByUid to yourself
      allow create: if signedIn()
        && request.resource.data.createdByUid == request.auth.uid
        && (request.resource.data.status == 'open' || request.resource.data.status == 'pending')
        && (!('courierUid' in request.resource.data) || request.resource.data.courierUid == null);

      // read job: creator, assigned courier, or any signed-in user for open/pending jobs
      allow read: if signedIn() && (
        isCreator()
        || isAssignedCourier()
        || resource.data.status == 'open'
        || resource.data.status == 'pending'
      );

      // update job
      allow update: if signedIn() && (
        // 1) Creator can cancel their own job if status is 'open', 'pending', or 'assigned'
        (
          isCreator() 
          && request.resource.data.status == 'cancelled'
          && (resource.data.status == 'open' || resource.data.status == 'pending' || resource.data.status == 'assigned')
        )
        ||
        // 2) Any courier can claim an open or pending job (atomic claim)
        (
          (resource.data.status == 'open' || resource.data.status == 'pending')
          && (!('courierUid' in resource.data) || resource.data.courierUid == null)
          && request.resource.data.courierUid == request.auth.uid
          && request.resource.data.status == 'assigned'
        )
        ||
        // 3) Assigned courier can update job progress
        (
          isAssignedCourier()
          && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['courierUid', 'createdByUid', 'agreedFee']))
          && validJobStatus(request.resource.data.status)
        )
      );
      
      // Admins have full access
      allow read, write: if isAdmin();

      allow delete: if false;
    }
    
    // ========== RATINGS ==========
    match /ratings/{ratingId} {
      // Anyone can read ratings
      allow read: if signedIn();
      
      // Only the fromUserId can create their rating
      allow create: if signedIn()
        && request.resource.data.fromUserId == request.auth.uid
        && request.resource.data.stars >= 1
        && request.resource.data.stars <= 5
        && request.resource.data.role in ['customer_to_courier', 'courier_to_customer'];
      
      // Cannot update or delete ratings
      allow update, delete: if false;
      
      // Admins can read all ratings
      allow read: if isAdmin();
    }
    
    // ========== DISPUTES ==========
    match /disputes/{disputeId} {
      function isReporter() {
        return signedIn() && resource.data.reportedBy == request.auth.uid;
      }
      
      function isReportedAgainst() {
        return signedIn() && resource.data.reportedAgainst == request.auth.uid;
      }
      
      // Read: reporter, reported user, or admin
      allow read: if signedIn() && (isReporter() || isReportedAgainst() || isAdmin());
      
      // Create: any user can create a dispute, or admins can create for testing
      allow create: if signedIn() && (
        (request.resource.data.reportedBy == request.auth.uid && request.resource.data.status == 'open') ||
        isAdmin() ||
        request.resource.data.testRecord == true
      );
      
      // Update: only admins can update disputes
      allow update: if isAdmin();
      
      allow delete: if false;
    }

    // ========== ROUTES (Local Delivery Routes) ==========
    match /routes/{routeId} {
      function isCourier() {
        return signedIn() && resource.data.get('courierId', null) == request.auth.uid;
      }
      
      // Any authenticated courier can view available routes
      allow read: if signedIn();
      
      // Couriers can claim routes (update status to 'claimed')
      allow update: if signedIn()
        && (request.resource.data.status == 'claimed' || isCourier());
      
      // Admins have full access
      allow read, write: if isAdmin();
      
      // Only system/cloud functions should create routes
      allow create, delete: if false;
    }

    // ========== LONG ROUTES (Regional Routes 50-200mi) ==========
    match /longRoutes/{routeId} {
      function isRunner() {
        return signedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'runner';
      }
      
      function isAssignedRunner() {
        return signedIn() && resource.data.get('runnerId', null) == request.auth.uid;
      }
      
      // Runners can view all long routes
      allow read: if isRunner();
      
      // Runners can accept routes and update their assigned routes
      allow update: if isRunner() && (request.resource.data.status == 'accepted' || isAssignedRunner());
      
      // Admins have full access
      allow read, write: if isAdmin();
      
      // Only system/cloud functions should create routes
      allow create, delete: if false;
    }

    // ========== LONG HAUL ROUTES (Interstate Routes 200+mi) ==========
    match /longHaulRoutes/{routeId} {
      function isAssignedRunner() {
        return signedIn() && resource.data.get('runnerId', null) == request.auth.uid;
      }
      
      function runnerMeetsRouteRequirements() {
        return isPackageRunner()
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data
              .get('packageRunnerProfile', {})
              .get('status', '') == 'approved'
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data
              .get('packageRunnerProfile', {})
              .get('commercialInsurance', {})
              .get('verified', false) == true
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data
              .get('packageRunnerProfile', {})
              .get('commercialInsurance', {})
              .get('coverageAmount', 0) >= 100000;
      }
      
      // Approved package runners can view all long haul routes
      allow read: if isPackageRunner();
      
      // Runners can claim routes if they meet requirements, or update their assigned routes
      allow update: if isPackageRunner() && (
        (request.resource.data.status == 'claimed' && resource.data.status == 'available' && runnerMeetsRouteRequirements()) ||
        (isAssignedRunner() && request.resource.data.status in ['accepted', 'in_progress', 'completed'])
      );
      
      // Admins have full access
      allow read, write: if isAdmin();
      
      // Only system/cloud functions should create routes
      allow create, delete: if false;
    }

    // ========== HUBS (Distribution Centers) ==========
    match /hubs/{hubId} {
      // Anyone can read hub information (needed for package shipping UI)
      allow read: if true;
      
      // Only admins can manage hubs
      allow create, update, delete: if isAdmin();
    }

    // ========== PACKAGES (Package Shipping) ==========
    match /packages/{packageId} {
      function isPackageSender() {
        return signedIn() && resource.data.senderId == request.auth.uid;
      }
      
      function isRunner() {
        return signedIn() && resource.data.get('runnerId', null) == request.auth.uid;
      }
      
      function isPackageRunner() {
        return signedIn() && request.auth.token.get('packageRunner', false) == true;
      }
      
      // Allow public read for tracking - anyone can track with tracking number
      allow read: if true; // Public tracking enabled
      
      // Any authenticated user can create a package as sender
      allow create: if signedIn()
        && request.resource.data.senderId == request.auth.uid;
      
      function senderCanCancel() {
        return isPackageSender()
          && resource.data.currentStatus in ['payment_pending', 'pickup_pending']
          && request.resource.data.currentStatus == 'cancelled'
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'currentStatus',
            'updatedAt'
          ]);
      }

      function senderCanEditMeta() {
        return isPackageSender()
          && request.resource.data.currentStatus == resource.data.currentStatus
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'refundRequested',
            'rating',
            'deliveryInstructions',
            'updatedAt'
          ]);
      }

      // Package runners and admins can update packages (for status changes)
      // Senders can cancel before pickup and manage their own metadata
      allow update: if isPackageRunner() || isAdmin() || senderCanCancel() || senderCanEditMeta();
      
      // Only admins can delete packages
      allow delete: if isAdmin();
    }

    // ========== FEATURE FLAGS ==========
    match /featureFlags/{doc} {
      // Anyone can read feature flags (needed for UI feature control)
      allow read: if true;
      
      // Only admins can manage feature flags
      allow create, update, delete: if isAdmin();
    }

    // ========== EQUIPMENT SUBMISSIONS ==========
    match /equipmentSubmissions/{submissionId} {
      // Couriers can read their own submissions
      allow read: if signedIn() && resource.data.courierId == request.auth.uid;
      
      // Couriers can create equipment submissions
      allow create: if signedIn() && request.resource.data.courierId == request.auth.uid;
      
      // Only admins can update/delete equipment submissions
      allow update, delete: if isAdmin();
      
      // Admins can read all submissions
      allow read: if isAdmin();
    }
    
    // ========== ADMIN ACTION LOGS (Audit Trail) ==========
    match /adminActionLogs/{logId} {
      // Only admins and system can create logs (typically via cloud function)
      allow create: if isAdmin();
      
      // Admins can read all audit logs
      allow read: if isAdmin();
      
      // No updates or deletes - immutable audit trail
      allow update, delete: if false;
    }

    // ========== PLATFORM SETTINGS ==========
    match /platformSettings/{settingId} {
      // Only admins can read and write platform settings
      allow read, write: if isAdmin();
    }

    // ========== MARKETPLACE ITEMS ==========
    match /marketplaceItems/{itemId} {
      // Anyone can read marketplace items
      allow read, list: if true;
      
      // Vendors can create items
      allow create: if signedIn() 
        && isVendor()
        && request.resource.data.vendorId == request.auth.uid
        && request.resource.data.status in ['draft', 'active', 'inactive']
        && request.resource.data.price > 0;
      
      // Vendors can update/delete their own items
      allow update, delete: if signedIn() && request.auth.uid == resource.data.vendorId;
      
      // Admins can do anything
      allow read, write: if isAdmin();
    }

    // ========== ORDERS ==========
    match /orders/{orderId} {
      // Anyone authenticated can list/query orders (filtering happens client-side)
      // Note: Individual read checks happen on specific documents
      allow list: if signedIn();
      
      // Customers can read their own orders
      allow get: if signedIn() && request.auth.uid == resource.data.customerId;
      
      // Vendors can read orders (will filter client-side for their items)
      allow get: if signedIn() && isVendor();
      
      // Customers can create orders
      allow create: if signedIn() 
        && request.resource.data.customerId == request.auth.uid
        && request.resource.data.items.size() > 0;
      
      // Vendors can update order status
      allow update: if signedIn() 
        && isVendor()
        && request.resource.data.status in ['pending', 'processing', 'shipped', 'delivered', 'cancelled'];
      
      // Customers can cancel pending orders
      allow update: if signedIn() 
        && request.auth.uid == resource.data.customerId
        && resource.data.status == 'pending'
        && request.resource.data.status == 'cancelled';
      
      // Admins can do anything
      allow read, write: if isAdmin();
    }

    // ========== VENDOR APPLICATIONS ==========
    match /vendorApplications/{userId} {
      // Users can read their own application
      allow read: if signedIn() && request.auth.uid == userId;
      
      // Users can create one application
      allow create: if signedIn() 
        && request.auth.uid == userId
        && request.resource.data.status == 'pending';
      
      // Users can update their pending application
      allow update: if signedIn() 
        && request.auth.uid == userId
        && resource.data.status == 'pending';
      
      // Admins can read and update all applications
      allow read, update: if isAdmin();
    }

    // ========== CATEGORIES (optional) ==========
    match /categories/{categoryId} {
      // Anyone can read categories
      allow read: if true;
      
      // Only admins can write categories
      allow write: if isAdmin();
    }

    // ========== REVIEWS ==========
    match /reviews/{reviewId} {
      // Anyone can read reviews
      allow read: if true;
      
      // Authenticated users can create reviews
      allow create: if signedIn() 
        && request.resource.data.reviewerId == request.auth.uid
        && request.resource.data.rating >= 1 
        && request.resource.data.rating <= 5;
      
      // Users can update their own reviews
      allow update: if signedIn() && request.auth.uid == resource.data.reviewerId;
      
      // Admins can do anything
      allow write: if isAdmin();
    }

    // ========== FEATURE FLAGS ==========
    match /featureFlags/{flagId} {
      // Anyone can read feature flags
      allow read: if true;
      
      // Only admins can write feature flags
      allow write: if isAdmin();
    }

    // ========== PLATFORM SETTINGS ==========
    match /platformSettings/{settingId} {
      // Anyone can read settings (may want to restrict this in production)
      allow read: if true;
      
      // Only admins can write settings
      allow write: if isAdmin();
    }

    // ========== ADMIN LOGS ==========
    match /adminLogs/{logId} {
      // Only admins can read logs
      allow read: if isAdmin();
      
      // Only admins can create logs (system creates them)
      allow create: if isAdmin();
    }

    // ========== DISPUTES ==========
    match /disputes/{disputeId} {
      // Users can read their own disputes, admins can read all
      allow read: if signedIn() && (
        isAdmin() ||
        request.auth.uid == resource.data.customerId ||
        request.auth.uid == resource.data.vendorId
      );
      
      // Authenticated users can create disputes
      allow create: if signedIn() && request.resource.data.customerId == request.auth.uid;
      
      // Only admins can update disputes
      allow update: if isAdmin();
    }

    // ========== ADMIN MESSAGES ==========
    match /adminMessages/{messageId} {
      // Allow authenticated admin users to read/write
      // In emulator/dev, allow any authenticated user
      allow read: if signedIn();
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if signedIn();
    }

    // ========== PAYOUTS ==========
    match /payouts/{payoutId} {
      // Couriers can read their own payouts
      allow read: if signedIn() && (
        isAdmin() ||
        request.auth.uid == resource.data.courierUid
      );
      
      // Only admins can create/update payouts
      allow create, update: if isAdmin();
    }
  }
}
